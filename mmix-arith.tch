@x [0]
\input pdfwebtocfront
@y
\pdfpagewidth=\pagewidth \advance\pdfpagewidth by 1in
\pdfpageheight=\fullpageheight \advance\pdfpageheight by 1in
\ifpdflua \pdfhorigin=0.5in \pdfvorigin=0.5in
\else \global\pageshift=-0.5in
  \global\hoffset=-0.5in \global\voffset=-0.5in \fi
@z

@x [31]
@^accuracy loss@>
@y
@^accuracy loss@>
@-X_BIT@>
@-Z_BIT@>
@-U_BIT@>
@-O_BIT@>
@-I_BIT@>
@-W_BIT@>
@-E_BIT@>
@z
@x [31]
  char s, /* the sign */
  int r) /* the rounding mode */
{
@y
  char s, /* the sign */
  int r) /* the rounding mode */
{ @+
@z

@x [36]
@ The |funpack| routine is, roughly speaking, the opposite of |fpack|.
@y
@r @ The |funpack| routine is, roughly speaking, the opposite of |fpack|.
@z

@x [40]
  if (s=='-') x.h|=sign_bit;
  return x;
}
@y
  if (s=='-') x.h|=sign_bit;
  return x;
}
@r
@z

@x [44]
if (x.h||x.l) xf.l|=1; /* adjust the sticky bit */
return fpack(xf,xe,xs,cur_round);
@y
if (x.h||x.l) xf.l|=1; /* adjust the sticky bit */
return fpack(xf,xe,xs,cur_round);
@r
@z

@x [46]
octa fplus(
  octa y, octa z)
{
@y
octa fplus(
  octa y, octa z)
{ @+
@z
@x [46]
  ftype yt=funpack(y,&yf,&ye,&ys),@|zt=funpack(z,&zf,&ze,&zs);
@y
  ftype yt=funpack(y,&yf,&ye,&ys),zt=funpack(z,&zf,&ze,&zs);
@z
@x [46]
  @=/* else fall through */@>@;
@y
  @+ @=/* else fall through */@>@;
@z
@x [46]
  @=/* else fall through */@>@;
@y
  @+ @=/* else fall through */@>@;
@z

@x [54]
representation that will be input as precisely the same value.
@y
representation that will be input as precisely the same value.
@$e {MMIX-ARITH}56 \&{register} \&{int}@>
@$f {MMIX-ARITH}56 \&{octa}@>
@$g {MMIX-ARITH}56 \&{octa}@>
@$s {MMIX-ARITH}66 \&{char} [\,]@>
@z

@x [59]
If |f| points to a \&{bignum}, its radix-$2^{28}$ digits are
@y
@-f@>
If |f| points to a \&{bignum}, its radix-$2^{28}$ digits are
@z

@x [60]
@ Here, for example, is how we go from $f$ to $10f$, assuming that
@y
@r @ Here, for example, is how we go from $f$ to $10f$, assuming that
@z

@x [63]
is exactly~1 the integer part of~$g$ will also be exactly~1.
@y
is exactly~1 the integer part of~$g$ will also be exactly~1.
@$ff {MMIX-ARITH}66 \&{bignum}@>
@$f {MMIX-ARITH}56 \&{octa}@>
@$g {MMIX-ARITH}56 \&{octa}@>
@z
@x [63]
ff.a=(ff.dat[k-1]? k-1: k);
ff.b=(ff.dat[k+1]? k+1: k);
gg.a=(gg.dat[k-1]? k-1: k);
gg.b=(gg.dat[k+1]? k+1: k);
@y
ff.a=(ff.dat[k-1]? k-1: k); @+
ff.b=(ff.dat[k+1]? k+1: k);
gg.a=(gg.dat[k-1]? k-1: k); @+
gg.b=(gg.dat[k+1]? k+1: k);
@z

@x [64]
But no harm is done, because |bignum_compare| is not used.
@y
But no harm is done, because |bignum_compare| is not used.
@$p {MMIX-ARITH}66 \&{register} \&{char} ${*}$@>
@z

@x [65]
and we do not terminate the process when $f=0$ or $g=1$.
@y
and we do not terminate the process when $f=0$ or $g=1$.
@$x {MMIX-ARITH}54 \&{octa}@>
@$tt {MMIX-ARITH}66 \&{bignum}@>
@z

@x [67]
@ At this point the significant digits are in string |s|, and |s[0]!='0'|.
@y
@r @ At this point the significant digits are in string |s|, and |s[0]!='0'|.
@z

@x [68]
\<floating magnitude>\is\<digit string>\<exponent>\mid
@y
\<floating magnitude>\is\<digit string>\<exponent>\mid\cr\hskip12em
@z
@x [68]
The value of |exceptions| set by |scan_const| is not necessarily correct.
@y
The value of |exceptions| set by |scan_const| is not necessarily correct.
@$p {MMIX-ARITH}70 \&{register} \&{char} ${*}$@>
@z

@x [70]
@ @<Local variables for |scan_const|@>=
@y
@r @ @<Local variables for |scan_const|@>=
@z

@x [73]
  exp=0;
@y
  @+ exp=0;
@z

@x [75]
  p++;
@y
  @+ p++;
@z

@x [78]
@ @<Return a floating point constant@>=
@y
@ @$ff {MMIX-ARITH}81 \&{bignum}@> @<Return a floating point constant@>=
@z

@x [79]
by $10^{9k}$, for $36\ge k\ge-120$.
@y
by $10^{9k}$, for $36\ge k\ge-120$.
@$k {MMIX-ARITH}81 \&{register} \&{int}@>
@$x {MMIX-ARITH}81 \&{register} \&{int}@>
@z
@x [79]
  exp=-99999;@+ goto packit;
@y
  @+ exp=-99999;@+ goto packit; @+
@z

@x [80]
@ @<Put the 9-digit number...@>=
{
@y
@ @<Put the 9-digit number...@>=
{ @+
@z

@x [82]
  register tetra *p,*q; register int x,carry;
@y
  @+ register tetra *p,*q; register int x,carry;
@z

@x [88]
@ To convert floating point to fixed point, we use |fixit|.
@y
@r @ To convert floating point to fixed point, we use |fixit|.
@z

@x [91]
  octa x,xf,rf,zf;
  int ze;
@y
  octa x,xf,rf,zf;
  int ze; @+
@z
@x [91]
  else@+switch (zt) {
@y
  else switch (zt) {
@z

@x [94]
if (ye>=ze) {
  exceptions|=E_BIT;@+return fpack(yf,ye,ys,ROUND_OFF);
}
@y
if (ye>=ze) { @+
  exceptions|=E_BIT;@+return fpack(yf,ye,ys,ROUND_OFF); @+
}
@z

@x [96]
@(mmix-arith.h@>=
@y
@-MMIX_ARITH_H@>
@(mmix-arith.h@>=
@z

@x [97]
@ @<External proto...@>=
@y
@ @-sim@> @-u@> @<External proto...@>=
@z

@x [98]
@* Index.
@y
@z
