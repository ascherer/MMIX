@x [0]
\input pdfwebtocfront
@y
\ifx\undefined\pdfpagewidth \else
\pdfpagewidth=\pagewidth \advance\pdfpagewidth by 1in
\pdfpageheight=\fullpageheight \advance\pdfpageheight by 1in
\ifpdflua \pdfhorigin=0.5in \pdfvorigin=0.5in
\else \global\hoffset=-0.5in \global\voffset=-0.5in \fi \fi

\ifx\undefined\eightpoint \input pdfwebtocfront \else
{\eightpoint \let\ninett=\eighttt \editorsnote \vskip7mm}
\fi
@z

@x [2]
static octa fpack(octa,int,char,int);
@y
@%
@$fpack {MMIX-ARITH}31 \&{static} \&{octa} (\,)@>
@$sfpack {MMIX-ARITH}34 \&{static} \&{tetra} (\,)@>
@$funpack {MMIX-ARITH}37 \&{static} \&{ftype} (\,)@>
@$sfunpack {MMIX-ARITH}38 \&{static} \&{ftype} (\,)@>
@$bignum_times_ten {MMIX-ARITH}60 \&{static} \&{void} (\,)@>
@$bignum_compare {MMIX-ARITH}61 \&{static} \&{int} (\,)@>
@$bignum_dec {MMIX-ARITH}62 \&{static} \&{void} (\,)@>
@$bignum_double {MMIX-ARITH}82 \&{static} \&{void} (\,)@>
static octa fpack(octa,int,char,int);
@z

@x [3]
@ The definition of type \&{tetra}
@y
@r @ The definition of type \&{tetra}
@z

@x [31]
@^accuracy loss@>
@y
@^accuracy loss@>
@-X_BIT@>
@-Z_BIT@>
@-U_BIT@>
@-O_BIT@>
@-I_BIT@>
@-W_BIT@>
@-E_BIT@>
@z
@x [31]
  char s, /* the sign */
  int r) /* the rounding mode */
{
@y
  char s, /* the sign */
  int r) /* the rounding mode */
{ @+
@z

@x [36]
@ The |funpack| routine is, roughly speaking, the opposite of |fpack|.
@y
@r @ The |funpack| routine is, roughly speaking, the opposite of |fpack|.
@z

@x [40]
  if (s=='-') x.h|=sign_bit;
  return x;
}
@y
  if (s=='-') x.h|=sign_bit;
  return x;
}
@r
@z

@x [44]
if (x.h||x.l) xf.l|=1; /* adjust the sticky bit */
return fpack(xf,xe,xs,cur_round);
@y
if (x.h||x.l) xf.l|=1; /* adjust the sticky bit */
return fpack(xf,xe,xs,cur_round);
@r
@z

@x [46]
octa fplus(
  octa y, octa z)
{
@y
octa fplus(
  octa y, octa z)
{ @+
@z
@x [46]
  ftype yt=funpack(y,&yf,&ye,&ys),@|zt=funpack(z,&zf,&ze,&zs);
@y
  ftype yt=funpack(y,&yf,&ye,&ys),zt=funpack(z,&zf,&ze,&zs);
@z
@x [46]
  @=/* else fall through */@>@;
@y
  @+ @=/* else fall through */@>@;
@z
@x [46]
  @=/* else fall through */@>@;
@y
  @+ @=/* else fall through */@>@;
@z

@x [54]
representation that will be input as precisely the same value.
@y
representation that will be input as precisely the same value.
@$e {MMIX-ARITH}56 \&{register} \&{int}@>
@$f {MMIX-ARITH}56 \&{octa}@>
@$g {MMIX-ARITH}56 \&{octa}@>
@$s {MMIX-ARITH}66 \&{char} [\,]@>
@z

@x [59]
If |f| points to a \&{bignum}, its radix-$2^{28}$ digits are
@y
@-f@>
If |f| points to a \&{bignum}, its radix-$2^{28}$ digits are
@z

@x [60]
@ Here, for example, is how we go from $f$ to $10f$, assuming that
@y
@r @ Here, for example, is how we go from $f$ to $10f$, assuming that
@z

@x [63]
is exactly~1 the integer part of~$g$ will also be exactly~1.
@y
is exactly~1 the integer part of~$g$ will also be exactly~1.
@$ff {MMIX-ARITH}66 \&{bignum}@>
@$f {MMIX-ARITH}56 \&{octa}@>
@$g {MMIX-ARITH}56 \&{octa}@>
@z
@x [63]
ff.a=(ff.dat[k-1]? k-1: k);
ff.b=(ff.dat[k+1]? k+1: k);
gg.a=(gg.dat[k-1]? k-1: k);
gg.b=(gg.dat[k+1]? k+1: k);
@y
ff.a=(ff.dat[k-1]? k-1: k); @+
ff.b=(ff.dat[k+1]? k+1: k);
gg.a=(gg.dat[k-1]? k-1: k); @+
gg.b=(gg.dat[k+1]? k+1: k);
@z

@x [64]
But no harm is done, because |bignum_compare| is not used.
@y
But no harm is done, because |bignum_compare| is not used.
@$p {MMIX-ARITH}66 \&{register} \&{char} ${*}$@>
@z

@x [65]
and we do not terminate the process when $f=0$ or $g=1$.
@y
and we do not terminate the process when $f=0$ or $g=1$.
@$x {MMIX-ARITH}54 \&{octa}@>
@$tt {MMIX-ARITH}66 \&{bignum}@>
@z

@x [67]
@ At this point the significant digits are in string |s|, and |s[0]!='0'|.
@y
@r @ At this point the significant digits are in string |s|, and |s[0]!='0'|.
@z

@x [68]
\<floating magnitude>\is\<digit string>\<exponent>\mid
@y
\<floating magnitude>\is\<digit string>\<exponent>\mid\cr\hskip12em
@z
@x [68]
The value of |exceptions| set by |scan_const| is not necessarily correct.
@y
The value of |exceptions| set by |scan_const| is not necessarily correct.
@$p {MMIX-ARITH}70 \&{register} \&{char} ${*}$@>
@z

@x [70]
@ @<Local variables for |scan_const|@>=
@y
@r @ @<Local variables for |scan_const|@>=
@z

@x [73]
  exp=0;
@y
  @+ exp=0;
@z

@x [75]
  p++;
@y
  @+ p++;
@z

@x [78]
@ @<Return a floating point constant@>=
@y
@ @$ff {MMIX-ARITH}81 \&{bignum}@> @<Return a floating point constant@>=
@z

@x [79]
by $10^{9k}$, for $36\ge k\ge-120$.
@y
by $10^{9k}$, for $36\ge k\ge-120$.
@$k {MMIX-ARITH}81 \&{register} \&{int}@>
@$x {MMIX-ARITH}81 \&{register} \&{int}@>
@z
@x [79]
  exp=-99999;@+ goto packit;
@y
  @+ exp=-99999;@+ goto packit; @+
@z

@x [80]
@ @<Put the 9-digit number...@>=
{
@y
@ @<Put the 9-digit number...@>=
{ @+
@z

@x [82]
  register tetra *p,*q; register int x,carry;
@y
  @+ register tetra *p,*q; register int x,carry;
@z

@x [88]
@ To convert floating point to fixed point, we use |fixit|.
@y
@r @ To convert floating point to fixed point, we use |fixit|.
@z

@x [91]
  octa x,xf,rf,zf;
  int ze;
@y
  octa x,xf,rf,zf;
  int ze; @+
@z
@x [91]
  else@+switch (zt) {
@y
  else switch (zt) {
@z

@x [94]
if (ye>=ze) {
  exceptions|=E_BIT;@+return fpack(yf,ye,ys,ROUND_OFF);
}
@y
if (ye>=ze) { @+
  exceptions|=E_BIT;@+return fpack(yf,ye,ys,ROUND_OFF); @+
}
@z

@x [96]
@(mmix-arith.h@>=
@y
@-MMIX_ARITH_H@>
@(mmix-arith.h@>=
@z

@x [98]
@ @<External proto...@>=
@y
@ @-sim@> @-u@> @<External proto...@>=
@z
@x [98]
Extern void print_octa(octa);
@y
@%
@$print_octa {MMIX-ARITH}4 \&{void} (\,)@>
@$oplus {MMIX-ARITH}5 \&{octa} (\,)@>
@$ominus {MMIX-ARITH}5 \&{octa} (\,)@>
@$incr {MMIX-ARITH}6 \&{octa} (\,)@>
@$shift_left {MMIX-ARITH}7 \&{octa} (\,)@>
@$shift_right {MMIX-ARITH}7 \&{octa} (\,)@>
@$omult {MMIX-ARITH}8 \&{octa} (\,)@>
@$signed_omult {MMIX-ARITH}12 \&{octa} (\,)@>
@$odiv {MMIX-ARITH}13 \&{octa} (\,)@>
@$signed_odiv {MMIX-ARITH}24 \&{octa} (\,)@>
@$onot {MMIX-ARITH}25 \&{octa} (\,)@>
@$oor {MMIX-ARITH}25 \&{octa} (\,)@>
@$oorn {MMIX-ARITH}25 \&{octa} (\,)@>
@$onor {MMIX-ARITH}25 \&{octa} (\,)@>
@$oand {MMIX-ARITH}25 \&{octa} (\,)@>
@$oandn {MMIX-ARITH}25 \&{octa} (\,)@>
@$onand {MMIX-ARITH}25 \&{octa} (\,)@>
@$oxor {MMIX-ARITH}25 \&{octa} (\,)@>
@$onxor {MMIX-ARITH}25 \&{octa} (\,)@>
@$count_bits {MMIX-ARITH}26 \&{int} (\,)@>
@$byte_diff {MMIX-ARITH}27 \&{tetra} (\,)@>
@$wyde_diff {MMIX-ARITH}28 \&{tetra} (\,)@>
@$bool_mult {MMIX-ARITH}29 \&{octa} (\,)@>
@$load_sf {MMIX-ARITH}39 \&{octa} (\,)@>
@$store_sf {MMIX-ARITH}40 \&{octa} (\,)@>
@$fmult {MMIX-ARITH}41 \&{octa} (\,)@>
@$fdivide {MMIX-ARITH}44 \&{octa} (\,)@>
@$fplus {MMIX-ARITH}46 \&{octa} (\,)@>
@$fepscomp {MMIX-ARITH}50 \&{int} (\,)@>
@$print_float {MMIX-ARITH}54 \&{void} (\,)@>
@$scan_const {MMIX-ARITH}68 \&{int} (\,)@>
@$fcomp {MMIX-ARITH}85 \&{int} (\,)@>
@$fintegerize {MMIX-ARITH}86 \&{octa} (\,)@>
@$fixit {MMIX-ARITH}88 \&{octa} (\,)@>
@$floatit {MMIX-ARITH}89 \&{octa} (\,)@>
@$froot {MMIX-ARITH}91 \&{octa} (\,)@>
@$fremstep {MMIX-ARITH}93 \&{octa} (\,)@>
Extern void print_octa(octa);
@z
