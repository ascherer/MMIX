@x [0]
\input pdfwebtocfront
@y
\pdfpagewidth=\pagewidth \advance\pdfpagewidth by 1in
\pdfpageheight=\fullpageheight \advance\pdfpageheight by 1in
\ifpdflua \pdfhorigin=0.5in \pdfvorigin=0.5in
\else \global\pageshift=-0.5in
  \global\hoffset=-0.5in \global\voffset=-0.5in \fi

{\eightpoint \let\ninett=\eighttt \editorsnote \vskip7mm}
@z

@x [5]
@(mmix-pipe.h@>=
@y
@-MMIX_PIPE_H@>
@(mmix-pipe.h@>=
@z

@x [7]
@ Some of the names that are natural for this program are in
@y
@r @ Some of the names that are natural for this program are in
@z
@x [7]
bypass the library names here.
@y
bypass the library names here.
@-my_div@> @-my_fsqrt@> @-my_random@>
@z

@x [12]
@ @<Local var...@>=
@y
@r @ @<Local var...@>=
@z

@x [26]
@ Coroutine control is masterminded by a ring of queues, one each for
@y
@r @ Coroutine control is masterminded by a ring of queues, one each for
@z

@x [27]
|schedule(c,d,s)|. (The |s| parameter is used only if scheduling is
@y
the function |schedule(c,d,s)|. (The |s| parameter is used only if scheduling is
@z

@x [35]
static coroutine *queuelist(int);

@ @<Sub...@>=
@y
static coroutine *queuelist(int);

@r @ @<Sub...@>=
@z

@x [48]
@!POP,@!RESUME,@!SAVE,@!UNSAVE,@!SYNC,@!SWYM,@!GET,@!TRIP}@+@!mmix_opcode;

@ @<Glob...@>=
@y
@!POP,@!RESUME,@!SAVE,@!UNSAVE,@!SYNC,@!SWYM,@!GET,@!TRIP}@+@!mmix_opcode;

@r @ @<Glob...@>=
@z

@x [50]
static char *internal_op_name[]={
@y
static char *internal_op_name[]={@|
@z
@x [50]
"mul8",
@y
"mul8",@|
@z
@x [50]
"fsqrt",
@y
"fsqrt",@|
@z
@x [50]
"frem",
@y
"frem",@|
@z
@x [50]
"set",
@y
"set",@|
@z
@x [50]
"nxor",
@y
"nxor",@|
@z
@x [50]
"odif",
@y
"odif",@|
@z
@x [50]
"ldvts",
@y
"ldvts",@|
@z
@x [50]
"cswap",
@y
"cswap",@|
@z
@x [50]
"resume",
@y
"resume",@|
@z
@x [50]
"trip",
@y
"trip",@|
@z

@x [53]
static char *special_name[32]={"rB","rD","rE","rH","rJ","rM","rR","rBB",
 "rC","rN","rO","rS","rI","rT","rTT","rK","rQ","rU","rV","rG","rL",
 "rA","rF","rP","rW","rX","rY","rZ","rWW","rXX","rYY","rZZ"};
@y
static char *special_name[32]={@|"rB","rD","rE","rH","rJ","rM","rR","rBB",@|
 "rC","rN","rO","rS","rI","rT","rTT","rK",@|"rQ","rU","rV","rG","rL",
 "rA","rF","rP",@|"rW","rX","rY","rZ","rWW","rXX","rYY","rZZ"};
@z

@x [54]
@ Here are the bit codes that affect trips and traps. The first eight
@y
@r @ Here are the bit codes that affect trips and traps. The first eight
@z

@x [61]
hot=cool=reorder_top;
@y
hot=cool=reorder_top; @+
@z

@x [78]
@ It is convenient to have
@y
@r @ It is convenient to have
@z

@x [84]
@ @<Convert relative...@>=
{
@y
@ @<Convert relative...@>=
{ @+
@z
@x [84]
  cool->z.o=incr(head->loc,yz<<2), cool->z.p=NULL;
@y
  cool->z.o=incr(head->loc,yz<<2), cool->z.p=NULL; @+
@z

@x [89]
@ The |addr| fields in the specnode lists for registers are used
to identify that register in diagnostic messages. Such addresses
@y
@ The |addr| fields in the specnode lists are used
to identify the register in diagnostic messages. Such addresses
@z

@x [94]
static void spec_install(specnode*,specnode*);
@y
static void spec_install(specnode*,specnode*);
@-spec_install@>
@z

@x [95]
static void spec_install( /* insert |t| into list |r| */
@y
@-spec_install@>
static void spec_install( /* insert |t| into list |r| */
@z

@x [96]
static void spec_rem(specnode*);

@ @<Sub...@>=
@y
static void spec_rem(specnode*);
@-spec_rem@>

@ @<Sub...@>=
@-spec_rem@>
@z

@x [109]
@ @<Set \9{c}|cool->z| as an immediate wyde@>=
@y
@r @ @<Set \9{c}|cool->z| as an immediate wyde@>=
@z

@x [114]
@ The |decgamma| instruction decreases $\gamma$ and rS by loading an octabyte
@y
@r @ The |decgamma| instruction decreases $\gamma$ and rS by loading an octabyte
@z

@x [118]
@ When new data is \.{PUT} into special registers 8 or 15--20 (namely rC, rK,
rQ, rU, rV, rG, or~rL) it can affect many things. Therefore we stop
@y
@ When new data is \.{PUT} into special registers 8 or 15--20 (namely |rC|, |rK|,
|rQ|, |rU|, |rV|, |rG|, or~|rL|) it can affect many things. Therefore we stop
@z

@x [122]
when the page table method isn't implemented in hardware.
@y
when the page table method isn't implemented in hardware.
\vskip1in
@z

@x [125]
    print_control_block(data);@+printf("\n");
  }
@y
    print_control_block(data);@+printf("\n"); @+
  }
@z

@x [131]
if (data->y.p) {
@y
if (data->y.p) { @+
@z
@x [131]
if (data->z.p) {
@y
if (data->z.p) { @+
@z
@x [131]
if (data->b.p) {
@y
if (data->b.p) { @+
@z
@x [131]
if (data->ra.p) {
@y
if (data->ra.p) { @+
@z

@x [138]
@ Here are the basic boolean operations, which account for 24 of \MMIX's
@y
@r @ Here are the basic boolean operations, which account for 24 of \MMIX's
@z

@x [144]
@ The other operations will be deferred until later, now that we understand
@y
@r @ The other operations will be deferred until later, now that we understand
@z

@x [145]
  cool_O=cool->cur_O;@+ cool_S=cool->cur_S;
@y
  cool_O=cool->cur_O;@+ cool_S=cool->cur_S; @+
@z

@x [149]
  }@+else if ((g[rK].o.h&0xff)!=0xff && !(hot->interrupt&S_BIT)) {
@y
  }@+else @/ if ((g[rK].o.h&0xff)!=0xff && !(hot->interrupt&S_BIT)) {
@z

@x [152]
@ We update the |bp_table| when an instruction is issued.
@y
@r @ We update the |bp_table| when an instruction is issued.
@z

@x [160]
@ If more than one functional unit is able to process branch instructions and
@y
@r @ If more than one functional unit is able to process branch instructions and
@z

@x [170]
static bool is_dirty(cache*,cacheblock*);

@ @<Sub...@>=
@y
static bool is_dirty(cache*,cacheblock*);

@r @ @<Sub...@>=
@z

@x [185]
  for (int j=0,jj=off>>c->g;j<c->bb>>c->g;j++,jj++) if (p->dirty[j]) {
@y
  for (int j=0,jj=off>>c->g;j<c->bb>>c->g;j++,jj++) if (p->dirty[j]) {
@$jj {MMIX-PIPE}185 \&{int}@>
@z
@x [185]
    for (int i=j<<(c->g-3),ii=jj<<(c->g-3),lim=(j+1)<<(c->g-3);
@y
    for (int i=j<<(c->g-3),ii=jj<<(c->g-3),lim=(j+1)<<(c->g-3);
@$ii {MMIX-PIPE}185 \&{int}@>
@$lim {MMIX-PIPE}185 \&{int}@>
@z

@x [213]
Extern void mem_write(octa addr,octa val);

@ @<External r...@>=
@y
Extern void mem_write(octa addr,octa val);

@r @ @<External r...@>=
@z

@x [217]
                   /* |p| not moved */
@y
@z

@x [218]
p=alloc_slot(Scache,c->outbuf.tag);
@y
p=alloc_slot(Scache,c->outbuf.tag); @+
@z

@x [225]
p=alloc_slot(Scache,data->z.o);
@y
p=alloc_slot(Scache,data->z.o); @+
@z
@x [224]
set_lock(&Scache->filler,mem_lock);
@y
set_lock(&Scache->filler,mem_lock); @+
@z

@x [227]
\dots, into the cache if it is not too busy.

@y
\dots, into the cache if it is not too busy.
@z

@x [236]
static char *DPTname[5]={"DPT0","DPT1","DPT2","DPT3","DPT4"};

@ @<Initialize e...@>=
@y
static char *DPTname[5]={"DPT0","DPT1","DPT2","DPT3","DPT4"};

@r @ @<Initialize e...@>=
@z

@x [238]
convenience. Whenever rV changes, we recompute all these variables.
@y
convenience. Whenever rV changes, we recompute all these variables.
@-b@> @-f@> @-n@> @-r@> @-s@>
@z

@x [239]
@ @<Update the \\{page} variables@>=
@y
@r @ @<Update the \\{page} variables@>=
@z

@x [245]
@ At this point the translation of the given virtual address |data->y.o| is
@y
@r @ At this point the translation of the given virtual address |data->y.o| is
@z

@x [251[
static void print_write_buffer(void);

@ @<Sub...@>=
@y
static void print_write_buffer(void);

@r @ @<Sub...@>=
@z

@x [256]
@<Commit to memory...@>=
{@+register write_node *q=write_tail;
@y
@<Commit to memory...@>=
{ register write_node *q=write_tail;
@z

@x [259]
(see |MMIX_config|). Although an uncached store will not be stored in the
@y
(see function |MMIX_config|). Although an uncached store will not be stored in the
@z

@x [268]
If the lower $b+c$ bits of the virtual and physical addresses differ,
@y
\vskip1cm
If the lower $b+c$ bits of the virtual and physical addresses differ,
@z

@x [271]
@ @<Do load/store stage 1 with known physical address@>=
{@+octa *m;
@y
@ @<Do load/store stage 1 with known physical address@>=
{octa *m;
@z
@x [271]
    data->state=st_ready;@+pass_after(1);@+goto passit;
@y
    data->state=st_ready; pass_after(1);@+goto passit;
@z
@x [271]
    data->state=DT_hit;@+pass_after(1);@+ goto passit;
@y
    data->state=DT_hit; pass_after(1);@+ goto passit;
@z

@x [273]
@ The second stage might also want to fill the D-cache (and perhaps
@y
@r @ The second stage might also want to fill the D-cache (and perhaps
@z

@x [291]
@ @d got_IT 19   /* |state| when IT-cache entry has been computed */
@y
@r @ @d got_IT 19   /* |state| when IT-cache entry has been computed */
@z

@x [300]
@ @<Try to get the contents of location |data->z.o| in the I-cache@>=
@y
@r @ @<Try to get the contents of location |data->z.o| in the I-cache@>=
@z

@x [304]
@ At this point we check for egregiously invalid instructions. (Sometimes
@y
@r @ At this point we check for egregiously invalid instructions. (Sometimes
@z

@x [308]
@ Since execution is speculative, an exceptional condition might not
@y
@r @ Since execution is speculative, an exceptional condition might not
@z

@x [314]
@ The following check is performed at the beginning of every cycle.
@y
@r @ The following check is performed at the beginning of every cycle.
@z

@x [319]
@ @<Set resumption registers $\rm(rB,\$255)$ or $\rm(rBB,\$255)$@>=
@y
@r @ @<Set resumption registers $\rm(rB,\$255)$ or $\rm(rBB,\$255)$@>=
@z

@x [321]
@ @<Set resumption registers $\rm(rY,rZ)$ or $\rm(rYY,rZZ)$@>=
@y
@r @ @<Set resumption registers $\rm(rY,rZ)$ or $\rm(rYY,rZZ)$@>=
@z

@x [322]
      cool->ren_a=true, spec_install(&g[rK],&cool->a);
      cool->a.known=true, cool->a.o=g[255].o;
      cool->ren_x=true, spec_install(&g[255],&cool->x);
      cool->x.known=true, cool->x.o=g[rBB].o;
@y
      cool->ren_a=true; spec_install(&g[rK],&cool->a);
      cool->a.known=true; cool->a.o=g[255].o;
      cool->ren_x=true; spec_install(&g[255],&cool->x);
      cool->x.known=true; cool->x.o=g[rBB].o;
@z

@x [332]
@ The instruction \.{UNSAVE} $z$ generates a sequence of internal instructions
@y
@r @ The instruction \.{UNSAVE} $z$ generates a sequence of internal instructions
@z

@x [337]
@ Of course \.{SAVE} is handled essentially like \.{UNSAVE}, but backwards.
@y
@r @ Of course \.{SAVE} is handled essentially like \.{UNSAVE}, but backwards.
@z

@x [346]
@d ROUND_NEAR 4
@y
@d ROUND_NEAR 4
@t}\vskip1cm{@>
@z

@x [351]
@ @<Begin execution of a stage-two operation@>=
@y
@r @ @<Begin execution of a stage-two operation@>=
@z

@x [359]
if (!Icache) {
  data->state=11;@+goto switch1;
@y
if (!Icache) { @+
  data->state=11;@+goto switch1; @+
@z

@x [364]
 if (!Icache) {
   data->state=(data->loc.h&sign_bit? 31:33);@+goto switch2;
@y
 if (!Icache) { @+
   data->state=(data->loc.h&sign_bit? 31:33);@+goto switch2; @+
@z
@x [364]
   { if (data->i==syncd) goto fin_ex;@+ else goto next_sync; }
@y
   { if (data->i==syncd) goto fin_ex; else goto next_sync; }
@z

@x [381]
@ The subroutine |mmgetchars(buf,size,addr,stop)| reads characters
@y
@r @ The subroutine |mmgetchars(buf,size,addr,stop)| reads characters
@z

@x [384]
  register unsigned char *p;
@y
  @+ register unsigned char *p;
@z

@x [385]
  register int s=8*((~a.l)&0x3);
@y
  @+ register int s=8*((~a.l)&0x3);
@z

@x [391]
@ The default |spec_write| just reports its arguments, without actually
@y
@r @ The default |spec_write| just reports its arguments, without actually
@z

@x [395]
@* Index.
@y
@z
