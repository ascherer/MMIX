@x [0]
\input pdfwebtocfront
@y
\ifx\undefined\pdfpagewidth \else
\pdfpagewidth=\pagewidth \advance\pdfpagewidth by 1in
\pdfpageheight=\fullpageheight \advance\pdfpageheight by 1in
\ifpdflua \pdfhorigin=0.5in \pdfvorigin=0.5in
\else \global\hoffset=-0.5in \global\voffset=-0.5in \fi \fi

\ifx\undefined\eightpoint \input pdfwebtocfront \else
{\eightpoint \let\ninett=\eighttt \editorsnote \vskip7mm}
\fi
@z

@x [5]
@(mmix-pipe.h@>=
@y
@-MMIX_PIPE_H@>
@(mmix-pipe.h@>=
@z

@x [7]
@ Some of the names that are natural for this program are in
@y
@r @ Some of the names that are natural for this program are in
@z
@x [7]
bypass the library names here.
@y
bypass the library names here.
@-my_div@> @-my_fsqrt@> @-my_random@>
@z

@x [12]
@ @<Local var...@>=
@y
@r @ @<Local var...@>=
@z

@x [13]
@d confusion(m) errprint("This can't happen: %s",m)
@y
@d confusion(m) errprint("This can't happen: %s",m)
@-x@> @-m@>
@z

@x [19]
octa read_hex(
@y
octa read_hex(
@-p@> @-d@> @-j@> @-k@> @-val@>
@z

@x [20]
  register int j; /* scratch variable */
@y
  register int j; /* scratch variable */ @-j@>
@z

@x [21]
the remainder in~|aux|.
@y
the remainder in~|aux|.
@-y@> @-z@>
@z

@x [25]
  if (c) printf("%s:%d",c->name,c->stage);
@y
  if (c) printf("%s:%d",c->name,c->stage); @+
@z
@x [25]
  if (c) errprint("%s:%d",c->name,c->stage);
  else errprint("??");
@y
  if (c) errprint("%s:%d",c->name,c->stage); @+
  else errprint("??");
@z

@x [26]
etc., from back to front, and we have |c->stage<=c->next->stage| unless |c=h|.
@y
etc., from back to front, and we have |c->stage<=c->next->stage| unless |c=h|.
@-c@> @-h@> @-p@>
@z
@x [26]
@<Initialize e...@>=@+
@y
@<Initialize e...@>=
@z

@x [27]
|schedule(c,d,s)|. (The |s| parameter is used only if scheduling is
@y
the function |schedule(c,d,s)|. (The |s| parameter is used only if scheduling is
@z
@x [27]
generally set |s| to the state at which the scheduled coroutine will begin.)
@y
generally set |s| to the state at which the scheduled coroutine will begin.)
@-c@> @-d@> @-s@>
@z

@x [28]
static void schedule(
@y
static void schedule(
@-p@>
@z

@x [30]
@ The all-important |ctl| field of a coroutine, which contains the
@y
@r @ The all-important |ctl| field of a coroutine, which contains the
@z

@x [32]
coroutine is not assumed to have any valid data in its |ctl| field.
@y
coroutine is not assumed to have any valid data in its |ctl| field.
@-c@>
@z

@x [33]
static void unschedule(
@y
static void unschedule(
@-p@>
@z

@x [34]
of Computer Programming}.
@y
of Computer Programming}.
@-t@>
@z

@x [35]
static coroutine *queuelist(int);

@ @<Sub...@>=
@y
static coroutine *queuelist(int);

@ @<Sub...@>=
@-p@> @-q@>
@z

@x [37]
@d release_lock(c,l) {@+l=NULL;@+ (c)->lockloc=NULL;@+}
@y
@d release_lock(c,l) {@+l=NULL;@+ (c)->lockloc=NULL;@+}
@-c@> @-l@>
@z

@x [39]
  if (mem_lock) printf("mem locked by %s:%d\n",mem_lock->name,mem_lock->stage);
@y
@t}\ifx\undefined\eightpoint\else\goodbreak\quad\fi{@>
  if (mem_lock) printf("mem locked by %s:%d\n",mem_lock->name,mem_lock->stage);
@z

@x [44]
the address of the subsequent instruction.
@y
the address of the subsequent instruction.
\ifx\undefined\eightpoint \else \vfill\vbox{}\vskip5mm \fi
@z

@x [48]
@!POP,@!RESUME,@!SAVE,@!UNSAVE,@!SYNC,@!SWYM,@!GET,@!TRIP}@+@!mmix_opcode;

@ @<Glob...@>=
@y
@!POP,@!RESUME,@!SAVE,@!UNSAVE,@!SYNC,@!SWYM,@!GET,@!TRIP}@+@!mmix_opcode;

@r @ @<Glob...@>=
@z

@x [49]
@!or, /* \.{OR[I]}, \.{OR[M][H,L]} */
@y
@!or, /* \.{OR[I]}, \.{OR[M][H,L]} */ @+ @t\qquad@>
@z
@x [49]
@!nor, /* \.{NOR[I]} */
@y
@!nor, /* \.{NOR[I]} */ @+ @t\qquad@>
@z
@x [49]
@!andn, /* \.{ANDN[I]}, \.{ANDN[M][H,L]} */
@y
@!andn, /* \.{ANDN[I]}, \.{ANDN[M][H,L]} */ @+ @t\qquad@>
@z
@x [49]
@!xor, /* \.{XOR[I]} */
@y
@!xor, /* \.{XOR[I]} */ @+ @t\qquad@>
@z
@x [49]
@!go, /* \.{GO[I]} */
@y
@!go, /* \.{GO[I]} */
@-go@>
@z
@x [49]
@!save, /* \.{SAVE} */
@y
@!save, /* \.{SAVE} */ @+ @t\qquad@>
@z
@x [49]
@!trap, /* \.{TRAP} */
@y
@!trap, /* \.{TRAP} */ @+ @t\qquad@>
@z

@x [50]
static char *internal_op_name[]={
@y
static char *internal_op_name[]={@|
@z
@x [50]
"mul8",
@y
"mul8",@|
@z
@x [50]
"fsqrt",
@y
"fsqrt",@|
@z
@x [50]
"frem",
@y
"frem",@|
@z
@x [50]
"set",
@y
"set",@|
@z
@x [50]
"nxor",
@y
"nxor",@|
@z
@x [50]
"odif",
@y
"odif",@|
@z
@x [50]
"ldvts",
@y
"ldvts",@|
@z
@x [50]
"cswap",
@y
"cswap",@|
@z
@x [50]
"resume",
@y
"resume",@|
@z
@x [50]
"trip",
@y
"trip",@|
@z

@x [51]
internal ones.
@y
internal ones.
@-go@> @% @$go {MMIX-PIPE}49 =72@>
@z

@x [53]
static char *special_name[32]={"rB","rD","rE","rH","rJ","rM","rR","rBB",
 "rC","rN","rO","rS","rI","rT","rTT","rK","rQ","rU","rV","rG","rL",
 "rA","rF","rP","rW","rX","rY","rZ","rWW","rXX","rYY","rZZ"};
@y
static char *special_name[32]={@|"rB","rD","rE","rH","rJ","rM","rR","rBB",@|
 "rC","rN","rO","rS","rI","rT","rTT","rK",@|"rQ","rU","rV","rG","rL",
 "rA","rF","rP",@|"rW","rX","rY","rZ","rWW","rXX","rYY","rZZ"};
@z

@x [54]
@ Here are the bit codes that affect trips and traps. The first eight
@y
@r @ Here are the bit codes that affect trips and traps. The first eight
@z

@x [56]
  for (int j=0,b=E_BIT;(x&(b+b-1))&&b;j++,b>>=1)
@y
  for (int j=0,b=E_BIT;(x&(b+b-1))&&b;j++,b>>=1)
@-x@> @-b@> @-j@>
@z

@x [58]
This simulator is based on the idea of ``dynamic scheduling with register
@y
\ifx\undefined\eightpoint \else \vfill \fi
This simulator is based on the idea of ``dynamic scheduling with register
@z
@x [58]
Some instructions in the reorder buffer may in fact be executed only
@y
\ifx\undefined\eightpoint \else \vfill \fi
Some instructions in the reorder buffer may in fact be executed only
@z
@x [58]
The reorder buffer is in fact a queue of \&{control} records, conceptually
@y
\ifx\undefined\eightpoint \else \vfill \fi
The reorder buffer is in fact a queue of \&{control} records, conceptually
@z
@x [58]
The best way to get an understanding of speculative execution is perhaps to
@y
\ifx\undefined\eightpoint \else \vfill \fi
The best way to get an understanding of speculative execution is perhaps to
@z
@x [58]
Instructions that have completed execution and have not yet been committed are
@y
\ifx\undefined\eightpoint \else \vfill \fi
Instructions that have completed execution and have not yet been committed are
@z

@x [59]
Suppose the simulated machine fetches the example \.{ADD} instruction
@y
\ifx\undefined\eightpoint \else \vfill \fi
Suppose the simulated machine fetches the example \.{ADD} instruction
@z
@x [59]
The dispatch unit of our simulator is able to issue up to |dispatch_max|
@y
\ifx\undefined\eightpoint \else \vfill \fi
The dispatch unit of our simulator is able to issue up to |dispatch_max|
@z
@x [59]
We assume that $\rm L>3$, so that \$1, \$2, and~\$3 are local registers.
@y
\ifx\undefined\eightpoint \else \vfill \fi
We assume that $\rm L>3$, so that \$1, \$2, and~\$3 are local registers.
@z
@x [59]
At time 1002, the ALU handling the \.{ADD} will stall if its inputs |y|
@y
\ifx\undefined\eightpoint \else \vfill \fi
At time 1002, the ALU handling the \.{ADD} will stall if its inputs |y|
@z
@x [59]
reorder buffer.
@y
reorder buffer.
@-b@> @-x@> @-y@> @-z@>
@z

@x [61]
hot=cool=reorder_top;
@y
hot=cool=reorder_top; @+
@z

@x [63]
    for (control* p=hot;p!=cool; p=(p==reorder_bot? reorder_top: p-1)) {
@y
    for (control* p=hot;p!=cool; p=(p==reorder_bot? reorder_top: p-1)) {
@-p@>
@z

@x [67]
@ @<Commit and/or deissue up to |commit_max| instructions@>=
@y
@ @<Commit and/or deissue up to |commit_max| instructions@>=
@%
@$i {MMIX-PIPE}12 \&{register} \&{int}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [68]
  unsigned int interrupt; /* bit codes that might cause interruption */
@y
  unsigned int interrupt; /* bit codes that might cause interruption */
@-loc@> @-inst@> @-interrupt@> @-noted@> @-hist@>
@z

@x [73]
static void print_fetch_buffer(void)
@y
@-p@>
@%
@$interrupt {MMIX-PIPE}68 \&{unsigned} \&{int}@>
@$p {MMIX-PIPE}73 \&{fetch} ${*}$@>
static void print_fetch_buffer(void)
@z

@x [75]
  register mmix_opcode op;
@y
  register mmix_opcode op;
@-op@> @$i {MMIX-PIPE}12 \&{register} \&{int}@>
@z

@x [78]
@ It is convenient to have
@y
@r @ It is convenient to have
@z

@x [79]
  for (int i=0;i<8;i++) support[i] |= u->ops[i];
@y
  for (int i=0;i<8;i++) support[i] |= u->ops[i];
@-i@> @-u@>
@z

@x [80]
@ @<Determine the flags, |f|, and the internal opcode, |i|@>=
@y
@ @<Determine the flags, |f|, and the internal opcode, |i|@>=
@% @$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [81]
@ @<Issue the |cool| instruction@>=
@y
@ @% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@<Issue the |cool| instruction@>=
@z

@x [82]
functional unit that supports |op| and has stage~1 unoccupied.
@y
functional unit that supports |op| and has stage~1 unoccupied.
@-t@> @-b@>
@%
@$i {MMIX-PIPE}12 \&{register} \&{int}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [84]
@ @<Convert relative...@>=
{
@y
@ @<Convert relative...@>=
{ @+
@% @$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z
@x [84]
  cool->z.o=incr(head->loc,yz<<2), cool->z.p=NULL;
@y
  cool->z.o=incr(head->loc,yz<<2), cool->z.p=NULL; @+
@z

@x [85]
is made in the common case that the speculative value of~rJ is known.
@y
is made in the common case that the speculative value of~rJ is known.
@% @$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [86]
rB is internally the same as g[0], because |rB=0|.
@y
rB is internally the same as g[0], because |rB=0|.
@-a@> @-x@>
@z

@x [89]
@ The |addr| fields in the specnode lists for registers are used
to identify that register in diagnostic messages. Such addresses
@y
@ The |addr| fields in the specnode lists are used
to identify the register in diagnostic messages. Such addresses
@z
@x [89]
@d SUBSUBVERSION 2 /* further qualification to version number */
@y
@d SUBSUBVERSION 2 /* further qualification to version number */
@%
@$j {MMIX-PIPE}20 \&{register} \&{int}@>
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@z

@x [91]
static void print_specnode_id(
@y
@-a@>
@%
@$l {MMIX-ARITH}3 \&{tetra}@>
static void print_specnode_id(
@z

@x [94]
static void spec_install(specnode*,specnode*);
@y
static void spec_install(specnode*,specnode*);
@-spec_install@>
@z

@x [95]
static void spec_install( /* insert |t| into list |r| */
@y
@-spec_install@>
static void spec_install( /* insert |t| into list |r| */
@z

@x [96]
static void spec_rem(specnode*);

@ @<Sub...@>=
@y
static void spec_rem(specnode*);
@-spec_rem@>

@ @<Sub...@>=
@-spec_rem@>
@z

@x [100]
@ @<Install default fields in the |cool| block@>=
@y
@ @<Install default fields in the |cool| block@>=
@%
@$i {MMIX-PIPE}12 \&{register} \&{int}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$op {MMIX-PIPE}44 \&{mmix\_opcode}@>
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [102]
have been unsaved, so we aren't fussy about it here.
@y
have been unsaved, so we aren't fussy about it here.
@$l {MMIX-ARITH}3 \&{tetra}@>
@%
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [103]
@ @<Install the operand fields of the |cool| block@>=
@y
@ @<Install the operand fields of the |cool| block@>=
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [104]
@ @<Set \9{c}|cool->z| from register Z@>=
@y
@ @<Set \9{c}|cool->z| from register Z@>=
@%
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@z

@x [105]
@ @<Set \9{c}|cool->y| from register Y@>=
@y
@ @<Set \9{c}|cool->y| from register Y@>=
@%
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@z

@x [106]
@ @<Set \9{c}|cool->b| from register X@>=
@y
@ @<Set \9{c}|cool->b| from register X@>=
@%
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@z

@x [108]
@<Set \9{c}|cool->b| and/or |cool->ra| from special register@>=
@y
@<Set \9{c}|cool->b| and/or |cool->ra| from special register@>=
@% @$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [109]
@ @<Set \9{c}|cool->z| as an immediate wyde@>=
@y
@r @ @<Set \9{c}|cool->z| as an immediate wyde@>=
@% @$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [110]
@ @<Install register X...@>=
@y
@ @<Install register X...@>=
@%
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@z

@x [112]
in the ring of local registers.
@y
in the ring of local registers.
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [113]
@<Insert \9{a}an instruction to advance gamma@>=
@y
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@<Insert \9{a}an instruction to advance gamma@>=
@z

@x [114]
@ The |decgamma| instruction decreases $\gamma$ and rS by loading an octabyte
@y
@r @ @%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
The |decgamma| instruction decreases $\gamma$ and rS by loading an octabyte
@z
@x [114]
      cool->rl.o.l=cool_L-1;
@y
      cool->rl.o.l=cool_L-1; @+
@z
@x [114]
  cool->z=cool->b=zero_spec; cool->need_b=false;
@y
  cool->z=cool->b=zero_spec; @+ cool->need_b=false;
@z

@x [117]
from memory before they write it.
@y
from memory before they write it.
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [118]
@ When new data is \.{PUT} into special registers 8 or 15--20 (namely rC, rK,
rQ, rU, rV, rG, or~rL) it can affect many things. Therefore we stop
@y
@ When new data is \.{PUT} into special registers 8 or 15--20 (namely |rC|, |rK|,
|rQ|, |rU|, |rV|, |rG|, or~|rL|) it can affect many things. Therefore we stop
@z
@x [118]
they reach the hot seat.
@y
they reach the hot seat.
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [119]
insert an~|incrl| command.
@y
insert an~|incrl| command.
@-x@>
@%
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@z

@x [120]
in order to maintain the condition $\rm rS\le rO$.
@y
in order to maintain the condition $\rm rS\le rO$.
@-x@> @-p@>
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@z

@x [122]
when the page table method isn't implemented in hardware.
@y
when the page table method isn't implemented in hardware.
\ifx\undefined\eightpoint \else \vskip1in \fi
@z

@x [124]
typically have |data->state=0| when a coroutine is first fired~up.
@y
typically have |data->state=0| when a coroutine is first fired~up.
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [125]
    print_control_block(data);@+printf("\n");
  }
@y
    print_control_block(data);@+printf("\n"); @+
  }
@-c@> @-t@>
@z
@x [125]
@+ register cacheblock *p,*q;
@y
@+ register cacheblock *p,*q; @-p@> @-q@>
@z

@x [128]
mem_locker.name="Locker";
@y
@% @$j {MMIX-PIPE}20 \&{register} \&{int}@>
mem_locker.name="Locker";
@z

@x [131]
if (data->y.p) {
@y
if (data->y.p) { @+
@z
@x [131]
if (data->z.p) {
@y
if (data->z.p) { @+
@z
@x [131]
if (data->b.p) {
@y
if (data->b.p) { @+
@z
@x [131]
if (data->ra.p) {
@y
if (data->ra.p) { @+
@z

@x [132]
the proper time.
@y
the proper time.
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [133]
added to~$t_k$.
@y
added to~$t_k$.
@-s@> @% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [134]
unit is |self+1|.
@y
unit is |self+1|.
@-s@> @% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [138]
@ Here are the basic boolean operations, which account for 24 of \MMIX's
@y
@r @ Here are the basic boolean operations, which account for 24 of \MMIX's
@z
@x [138]
case or: data->x.o=oor(data->y.o, data->z.o); @+ break;
case orn: data->x.o=oorn(data->y.o, data->z.o); @+ break;
case nor: data->x.o=onor(data->y.o, data->z.o); @+ break;
case and: data->x.o=oand(data->y.o, data->z.o); @+ break;
case andn: data->x.o=oandn(data->y.o, data->z.o); @+ break;
case nand: data->x.o=onand(data->y.o, data->z.o); @+ break;
case xor: data->x.o=oxor(data->y.o, data->z.o); @+ break;
case nxor: data->x.o=onxor(data->y.o, data->z.o); @+ break;
@y
case or: data->x.o=oor(data->y.o, data->z.o); break;
case orn: data->x.o=oorn(data->y.o, data->z.o); break;
case nor: data->x.o=onor(data->y.o, data->z.o); break;
case and: data->x.o=oand(data->y.o, data->z.o); break;
case andn: data->x.o=oandn(data->y.o, data->z.o); break;
case nand: data->x.o=onand(data->y.o, data->z.o); break;
case xor: data->x.o=oxor(data->y.o, data->z.o); break;
case nxor: data->x.o=onxor(data->y.o, data->z.o); break;
@z

@x [139]
case subu: data->x.o=ominus(data->y.o,data->z.o);@+ break;
@y
case subu: data->x.o=ominus(data->y.o,data->z.o); break;
@z

@x [141]
below.)
@y
below.)
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [144]
@ The other operations will be deferred until later, now that we understand
@y
@r @ The other operations will be deferred until later, now that we understand
@z

@x [145]
  cool_O=cool->cur_O;@+ cool_S=cool->cur_S;
@y
  cool_O=cool->cur_O;@+ cool_S=cool->cur_S; @+
@z

@x [146]
@ @<Commit the hottest instruction...@>=
@y
@ @<Commit the hottest instruction...@>=
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [149]
  }@+else if ((g[rK].o.h&0xff)!=0xff && !(hot->interrupt&S_BIT)) {
@y
  }@+else @/ if ((g[rK].o.h&0xff)!=0xff && !(hot->interrupt&S_BIT)) {
@z

@x [151]
don't want to update it yet.
@y
don't want to update it yet.
@% @$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [152]
@ We update the |bp_table| when an instruction is issued.
@y
@r @ We update the |bp_table| when an instruction is issued.
@-h@>
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [155]
prediction was correct or not.
@y
prediction was correct or not.
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [157]
static int register_truth(
@y
static int register_truth(
@-o@> @-op@> @-b@>
@z

@x [158]
the current |cool| pointer, when |cc=cool|.
@y
the current |cool| pointer, when |cc=cool|. @-cc@>
@z

@x [159]
static int issued_between(
@y
static int issued_between(
@-c@> @-cc@>
@z

@x [160]
@ If more than one functional unit is able to process branch instructions and
@y
@r @ If more than one functional unit is able to process branch instructions and
@z

@x [162]
  for (int j=0;j<=dispatch_max;j++)
@y
  for (int j=0;j<=dispatch_max;j++) @-j@>
@z

@x [167]
  octa *data; /* array of $2^{b-3}$ octabytes, the data in a cache block */
@y
  octa *data; /* array of $2^{b-3}$ octabytes, the data in a cache block */
@-c@> @-data@> @-g@>
@z

@x [170]
static bool is_dirty(cache*,cacheblock*);

@ @<Sub...@>=
@y
static bool is_dirty(cache*,cacheblock*);

@r @ @<Sub...@>=
@-c@> @-d@> @-j@> @-p@>
@z

@x [172]
{@+register int b=c->bb>>3,g=c->gg>>3;
@y
{@+register int b=c->bb>>3,g=c->gg>>3;
@-b@> @-c@> @-g@> @-i@> @-j@> @-p@>
@% @$data {MMIX-PIPE}167 \&{octa} ${*}$@>
@z

@x [174]
static void print_cache_locks(
@y
static void print_cache_locks(
@-c@>
@z

@x [176]
  if (c) {@+register int i,j;
@y
  if (c) {@+register int i,j;
@-c@> @-i@> @-j@>
@z

@x [177]
requested to be verbose.
@y
requested to be verbose.
@%
@$i {MMIX-PIPE}176 \&{register} \&{int}@>
@$j {MMIX-PIPE}176 \&{register} \&{int}@>
@z

@x [179]
  register int j;
@y
  register int j;
@-c@> @-j@> @-p@>
@%
@$data {MMIX-PIPE}167 \&{octa} ${*}$@>
@$g {MMIX-PIPE}167 \&{int}@>
@z

@x [181]
  register int i,j;
@y
  register int i,j;
@-c@> @-i@> @-j@>
@z

@x [183]
  for (int j=0;j<c->ports;j++)
@y
  for (int j=0;j<c->ports;j++)
@-c@> @-j@>
@z

@x [184]
@ The subroutine |copy_block(c,p,cc,pp)| copies the dirty
@y
@ The subroutine |copy_block(c,p,cc,pp)| copies the dirty
@-c@> @-p@> @-cc@> @-pp@>
@z

@x [185]
  for (int j=0,jj=off>>c->g;j<c->bb>>c->g;j++,jj++) if (p->dirty[j]) {
@y
  for (int j=0,jj=off>>c->g;j<c->bb>>c->g;j++,jj++) if (p->dirty[j]) {
@-c@> @-cc@> @-i@> @-ii@> @-lim@> @-j@> @-jj@> @-p@>
@%
@$data {MMIX-PIPE}167 \&{octa} ${*}$@>
@$g {MMIX-PIPE}167 \&{int}@>
@z

@x [186]
has rank~0, and the most recently used entry has rank~$2^a-1=|aa|-1$.
@y
has rank~0, and the most recently used entry has rank~$2^a-1=|aa|-1$.
@-aa@> @-policy@>
@z

@x [187]
  register int l,m;
@y
  register int l,m;
@-l@> @-m@>
@%
@$l {MMIX-ARITH}3 \&{tetra}@>
@z
@x [187]
 case lru: for (cacheblock* p=s;p<s+aa;p++)
@y
 case lru: for (cacheblock* p=s;p<s+aa;p++) @-p@>
@z

@x [189]
    for (cacheblock* p=s;p<s+aa;p++) if (p->rank>r) p->rank--;
@y
    for (cacheblock* p=s;p<s+aa;p++) if (p->rank>r) p->rank--; @-p@>
@z
@x [189]
    for (int j=1,m=aa>>1;m;m>>=1)
@y
    for (int j=1,m=aa>>1;m;m>>=1) @-j@> @-m@> @-l@> @-aa@>
@z

@x [191]
    for (cacheblock* p=s;p<s+aa;p++) if (p->rank<r) p->rank++;
@y
    for (cacheblock* p=s;p<s+aa;p++) if (p->rank<r) p->rank++; @-p@>
@z
@x [191]
    for (int j=1,m=aa>>1;m;m>>=1)
@y
    for (int j=1,m=aa>>1;m;m>>=1) @-j@> @-m@> @-l@>
@z
@x [191]
@d cache_addr(c,alf) c->set[(alf.l&~(c->tagmask))>>c->b]
@y
@d cache_addr(c,alf) c->set[(alf.l&~(c->tagmask))>>c->b]
@-c@> @-alf@> @-aa@>
@z

@x [193]
static cacheblock* cache_search(
@y
static cacheblock* cache_search( @-p@>
@z
@x [193]
  for (p=s;p<s+c->aa;p++)
@y
  for (p=s;p<s+c->aa;p++)
@-c@> @-alf@> @-p@> @-s@>
@$aa {MMIX-PIPE}167 \&{int}@>
@z

@x [195]
A pointer to the (possibly moved) cache block is returned.
@y
A pointer to the (possibly moved) cache block is returned.
@-p@> @-c@> @-alf@>
@z

@x [196]
      register cacheblock *q=choose_victim(s,c->aa,c->repl);
@y
      register cacheblock *q=choose_victim(s,c->aa,c->repl);
@-c@> @-p@> @-q@> @-s@>
@z

@x [197]
pointers escape into other data structures.
@y
pointers escape into other data structures.
@%
@$data {MMIX-PIPE}167 \&{octa} ${*}$@>
@$p {MMIX-PIPE}196 \&{cacheblock} ${*}$@>
@$p {MMIX-PIPE}205 \&{register} \&{cacheblock} ${*}$@>
@$q {MMIX-PIPE}196 \&{register} \&{cacheblock} ${*}$@>
@$q {MMIX-PIPE}205 \&{register} \&{cacheblock} ${*}$@>
@z

@x [199]
static cacheblock *demote_and_fix(
@y
static cacheblock *demote_and_fix(
@-c@> @-p@>
@z

@x [200]
to be placed in the cache block~|p|. 
@y
to be placed in the cache block~|p|. 
@-c@> @-p@>
@z

@x [201]
  for (int i=0;i<c->bb>>c->g;i++) p->dirty[i]=false;
@y
  for (int i=0;i<c->bb>>c->g;i++) p->dirty[i]=false;
@-c@> @-p@>
@-d@> @-i@>
@%
@$data {MMIX-PIPE}167 \&{octa} ${*}$@>
@$g {MMIX-PIPE}167 \&{int}@>
@z

@x [202]
Cache block~|p| is also marked clean.
@y
Cache block~|p| is also marked clean.
@-c@> @-p@> @-keep@>
@z

@x [203]
static void flush_cache(
@y
static void flush_cache(
@-c@> @-p@>
@-d@> @-dd@> @-j@>
@%
@$data {MMIX-PIPE}167 \&{octa} ${*}$@>
@$g {MMIX-PIPE}167 \&{int}@>
@z

@x [205]
  register cacheblock *p,*q;
@y
  register cacheblock *p,*q;
@-p@> @-q@>
@-c@> @-alf@> @-s@>
@z

@x [208]
@ The separately compiled procedures |spec_read()| and |spec_write()| have the
@y
@ The procedures |spec_read()| and |spec_write()| have the
@-size@>
@z

@x [210]
octa mem_read(
@y
@-h@>
@%
@$h {MMIX-PIPE}210 \&{register} \&{int}@>
@$h {MMIX-ARITH}3 \&{t}etra@>
octa mem_read(
@z

@x [213]
Extern void mem_write(octa addr,octa val);

@ @<External r...@>=
@y
Extern void mem_write(octa addr,octa val);

@r @ @<External r...@>=
@-h@>
@%
@$h {MMIX-PIPE}213 \&{register} \&{int}@>
@$h {MMIX-ARITH}3 \&{t}etra@>
@z

@x [214]
|mem_addr_time+c*mem_write_time|, respectively.
@y
|mem_addr_time+c*mem_write_time|, respectively.
@-c@>
@z

@x [215]
case flush_to_mem: {@+register cache *c=(cache *)data->ptr_a;
@y
case flush_to_mem: {@+register cache *c=(cache *)data->ptr_a;
@-c@>
@z

@x [216]
@ @<Write the dirty data of |c->outbuf| and wait for the bus@>=
@y
@ @<Write the dirty data of |c->outbuf| and wait for the bus@>=
@%
@$data {MMIX-PIPE}167 \&{octa} ${*}$@>
@$g {MMIX-PIPE}167 \&{int}@>
@$tag {MMIX-PIPE}167 \&{octa}@>
@z

@x [217]
of the present program are left to the interested reader.
@y
of the present program are left to the interested reader.
@-c@>
@$tag {MMIX-PIPE}167 \&{octa}@>
@%
@$data {MMIX-PIPE}124 \&{register} \&{control}${*}$@>
@$data {MMIX-PIPE}167 \&{octa} ${*}$@>
@$g {MMIX-PIPE}167 \&{int}@>
@$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z
@x [217]
                   /* |p| not moved */
@y
@z

@x [218]
p=alloc_slot(Scache,c->outbuf.tag);
@y
p=alloc_slot(Scache,c->outbuf.tag); @+
@% @$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [219]
@ We only need to read |block_diff| bytes, but it's easier to
@y
@ We only need to read |block_diff| bytes, but it's easier to
@%
@$data {MMIX-PIPE}124 \&{register} \&{control}${*}$@>
@$data {MMIX-PIPE}167 \&{octa} ${*}$@>
@z

@x [220]
  register octa *d=p->data;
@y
  register octa *d=p->data;
@%
@$data {MMIX-PIPE}167 \&{octa} ${*}$@>
@$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [221]
@ Here we assume that the granularity is~8.
@y
@ Here we assume that the granularity is~8.
@% @$g {MMIX-PIPE}167 \&{int}@>
@z

@x [222]
  register coroutine *cc=c->fill_lock;
@y
  register coroutine *cc=c->fill_lock;
@-c@> @-cc@>
@z

@x [223]
cycle, so that there will be two wakeup calls.
@y
cycle, so that there will be two wakeup calls.
@%
@$data {MMIX-PIPE}124 \&{register} \&{control}${*}$@>
@$data {MMIX-PIPE}167 \&{octa} ${*}$@>
@z

@x [224]
is present.
@y
is present.
@-c@> @-cc@>
@%
@$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [225]
p=alloc_slot(Scache,data->z.o);
@y
p=alloc_slot(Scache,data->z.o); @+
@% @$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z
@x [225]
set_lock(&Scache->filler,mem_lock);
@y
set_lock(&Scache->filler,mem_lock); @+
@z

@x [227]
\dots, into the cache if it is not too busy.

@y
\dots, into the cache if it is not too busy.
@z

@x [230]
identify their first dirty block, if any, in |access_time| cycles.
@y
identify their first dirty block, if any, in |access_time| cycles.
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [231]
clean_co.name="Clean";
@y
clean_co.name="Clean";
@% @$name {MMIX-PIPE}23 \&{char} ${*}$@>
@z

@x [232]
@ @<Cases for control of special...@>=
@y
@ @<Cases for control of special...@>=
@% @$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [233]
@ @<Cases 0 through 4, for the D-cache@>=
@y
@ @<Cases 0 through 4, for the D-cache@>=
@%
@$i {MMIX-PIPE}12 \&{register} \&{int}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [234]
@ @<Cases 5 through 9...@>=
@y
@ @<Cases 5 through 9...@>=
@%
@$i {MMIX-PIPE}12 \&{register} \&{int}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [235]
  if (!is_dirty(Scache,p)) {
    p->tag.h|=data->x.o.h;@+goto Sclean_inc;
@y
  if (!is_dirty(Scache,p)) { @+
    p->tag.h|=data->x.o.h;@+goto Sclean_inc; @+
@z

@x [236]
static char *DPTname[5]={"DPT0","DPT1","DPT2","DPT3","DPT4"};

@ @<Initialize e...@>=
@y
static char *DPTname[5]={"DPT0","DPT1","DPT2","DPT3","DPT4"};

@r @ @<Initialize e...@>=
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$name {MMIX-PIPE}23 \&{char} ${*}$@>
@z

@x [237]
@<Cases for control of special coroutines@>=
@y
@<Cases for control of special coroutines@>=
@-c@> @-cc@> @-co@>
@% @$b {MMIX-PIPE}44 \&{spec}@>
@z

@x [238]
convenience. Whenever rV changes, we recompute all these variables.
@y
convenience. Whenever rV changes, we recompute all these variables.
@-b@> @-f@> @-n@> @-r@> @-s@>
@z

@x [239]
@ @<Update the \\{page} variables@>=
@y
@r @ @<Update the \\{page} variables@>=
@z
@x [239]
  page_n=rv.l&0x1ff8;
@y
  page_n=rv.l&0x1ff8; @+
@z
@x [239]
  page_r=rv.l&0x7ffffff;
@y
  page_r=rv.l&0x7ffffff; @+
@z
@x [239]
  page_b[4]=(rv.l>>8)&0xf;
@y
  page_b[4]=(rv.l>>8)&0xf; @+
@z
@x [239]
  page_b[2]=(rv.l>>16)&0xf;
@y
  page_b[2]=(rv.l>>16)&0xf; @+
@z

@x [240]
@d trans_key(addr) incr(oandn(addr,page_mask),page_n)
@y
@d trans_key(addr) incr(oandn(addr,page_mask),page_n)
@-addr@>
@z

@x [243]
@<Start up auxiliary coroutines to compute the page table entry@>=
@y
@<Start up auxiliary coroutines to compute the page table entry@>=
@% @$b {MMIX-PIPE}44 \&{spec}@>
@z

@x [244]
@<Issue $j$ pseudo-instructions to compute a page table entry@>=
@y
@<Issue $j$ pseudo-instructions to compute a page table entry@>=
@% @$b {MMIX-PIPE}44 \&{spec}@>
@z

@x [245]
@ At this point the translation of the given virtual address |data->y.o| is
@y
@r @ At this point the translation of the given virtual address |data->y.o| is
@%
@$b {MMIX-PIPE}44 \&{spec}@>
@$data {MMIX-PIPE}124 \&{register} \&{control}${*}$@>
@$data {MMIX-PIPE}167 \&{octa} ${*}$@>
@z

@x [249]
write_co.name="Write";
@y
write_co.name="Write";
@% @$name {MMIX-PIPE}23 \&{char} ${*}$@>
@z

@x [251]
static void print_write_buffer(void);

@ @<Sub...@>=
@y
static void print_write_buffer(void);

@r @ @<Sub...@>=
@-p@>
@z

@x [255]
  register write_node *q=write_tail;
@y
  register write_node *q=write_tail;
@-addr@> @-ctl@> @-p@> @-q@>
@%
@$addr {MMIX-PIPE}40 \&{octa}@>
@$addr {MMIX-PIPE}246 \&{octa}@>
@$o {MMIX-PIPE}40 \&{octa}@>
@$o {MMIX-PIPE}246 \&{octa}@>
@z

@x [256]
@<Commit to memory...@>=
{@+register write_node *q=write_tail;
@y
\ifx\undefined\eightpoint \else \vfill\vbox{}\vskip1cm \fi
@<Commit to memory...@>=
{ register write_node *q=write_tail;
@-p@> @-q@>
@%
@$addr {MMIX-PIPE}40 \&{octa}@>
@$addr {MMIX-PIPE}246 \&{octa}@>
@$o {MMIX-PIPE}40 \&{octa}@>
@$o {MMIX-PIPE}246 \&{octa}@>
@z

@x [257]
to fill a block.
@y
to fill a block.
@% @$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [259]
(see |MMIX_config|). Although an uncached store will not be stored in the
@y
(see function |MMIX_config|). Although an uncached store will not be stored in the
@z
@x [259]
@<Handle write-around when writing to the D-cache@>=
@y
@<Handle write-around when writing to the D-cache@>=
@% @$g {MMIX-PIPE}167 \&{int}@>
@z

@x [260]
@ @<Write directly from |write_head| to memory@>=
@y
@r @ @<Write directly from |write_head| to memory@>=
@z
@x [260]
set_lock(&mem_locker,mem_lock); /* a coroutine of type |vanish| */
@y
@+ set_lock(&mem_locker,mem_lock); /* a |vanish| coroutine */
@z

@x [261]
@<Try to put the contents of location |write_head->addr| into the D-cache@>=
@y
@<Try to put the contents of location |write_head->addr| into the D-cache@>=
@% @$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z
@x [261]
if (Scache) set_lock(&Dcache->filler,Scache->lock)@;
else set_lock(&Dcache->filler,mem_lock);
@y
set_lock(&Dcache->filler, Scache ? Scache->lock : mem_lock);
@z
@x [261]
set_lock(self,Dcache->fill_lock);
data->ptr_b=Dcache->filler_ctl.ptr_b=(void *)p;
Dcache->filler_ctl.z.o=write_head->addr;
@y
set_lock(self,Dcache->fill_lock); @+
Dcache->filler_ctl.z.o=write_head->addr;
data->ptr_b=Dcache->filler_ctl.ptr_b=(void *)p;
@z

@x [262]
Perhaps the simulator is being too lenient here.
@y
Perhaps the simulator is being too lenient here.
@%
@$g {MMIX-PIPE}167 \&{int}@>
@$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [263]
  flush_cache(Dcache,p,true);
@y
  flush_cache(Dcache,p,true);
@% @$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [265]
  data->z.o=incr(data->z.o,data->xx&-(data->i==prego? Icache: Dcache)->bb);
  /* (I hope the adder is fast enough) */
@y
  /* (I hope the adder is fast enough) */
	data->z.o=incr(data->z.o,data->xx&-(data->i==prego? Icache: Dcache)->bb);
@$i {MMIX-PIPE}12 \&{register} \&{int}@>
@$o {MMIX-PIPE}40 \&{octa}@>
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [266]
@<Special cases for states in the first stage@>=
@y
@<Special cases for states in the first stage@>=
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [267]
@<Look up the address in the DT-cache...@>=
@y
@<Look up the address in the DT-cache...@>=
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [268]
If the lower $b+c$ bits of the virtual and physical addresses differ,
@y
\ifx\undefined\eightpoint \else \vskip1cm \fi
If the lower $b+c$ bits of the virtual and physical addresses differ,
@z
@x [268]
@d max(x,y) ((x)<(y)? (y):(x))
@y
@d max(x,y) ((x)<(y)? (y):(x))
@-x@> @-y@>
@%
@$c {MMIX-PIPE}167 \&{int}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@$q {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@$x {MMIX-PIPE}44 \&{specnode}@>
@$y {MMIX-PIPE}44 \&{spec}@>
@z

@x [269]
@<Check the protection bits and get the physical address@>=
@y
@<Check the protection bits and get the physical address@>=
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [270]
    p=use_and_fix(DTcache,p), data->z.o=p->data[0];
@y
    p=use_and_fix(DTcache,p), data->z.o=p->data[0];
@-m@>
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [271]
@ @<Do load/store stage 1 with known physical address@>=
{@+octa *m;
@y
@ @<Do load/store stage 1 with known physical address@>=
{octa *m;
@-m@>
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$q {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z
@x [271]
  data->z.o=data->y.o;@+ data->z.o.h -= sign_bit;
@y
  data->z.o=data->y.o; data->z.o.h -= sign_bit;
@z
@x [271]
    data->state=st_ready;@+pass_after(1);@+goto passit;
@y
    data->state=st_ready; pass_after(1);@+goto passit;
@z
@x [271]
    data->state=DT_hit;@+pass_after(1);@+ goto passit;
@y
    data->state=DT_hit; pass_after(1);@+ goto passit;
@z

@x [272]
@<Special cases for states in later stages@>=
@y
@<Special cases for states in later stages@>=
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [273]
@ The second stage might also want to fill the D-cache (and perhaps
@y
@r @ The second stage might also want to fill the D-cache (and perhaps
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$q {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [274]
@ @<Try to get the contents of location |data->z.o| in the D-cache@>=
@y
@ @<Try to get the contents of location |data->z.o| in the D-cache@>=
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$q {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [275]
@<Check for \9{p}|prest| with a fully spanned cache block@>=
@y
@<Check for \9{p}|prest| with a fully spanned cache block@>=
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [276]
@ @<Special cases for states in later stages@>=
@y
@ @<Special cases for states in later stages@>=
@%
@$q {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [278]
  octa *m=write_search(data,data->z.o);
@y
  octa *m=write_search(data,data->z.o);
@-m@>
@z

@x [279]
@<Special cases for states in later stages@>=
@y
@<Special cases for states in later stages@>=
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [280]
@ @<Special cases for states in later stages@>=
@y
@ @<Special cases for states in later stages@>=
@%
@$b {MMIX-PIPE}44 \&{spec}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [281]
@<Finish a store command@>=
@y
@<Finish a store command@>=
@%
@$b {MMIX-PIPE}44 \&{spec}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [282]
@ @<Insert \9{d}|data->b.o| into the proper field...@>=
@y
@ @<Insert \9{d}|data->b.o| into the proper field...@>=
@%
@$b {MMIX-PIPE}44 \&{spec}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [283]
@<Finish a \.{CSWAP}@>=
@y
@<Finish a \.{CSWAP}@>=
@%
@$a {MMIX-PIPE}44 \&{specnode}@>
@$b {MMIX-PIPE}44 \&{spec}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [286]
fetch_co.name="Fetch";
@y
fetch_co.name="Fetch";
@% @$name {MMIX-PIPE}23 \&{char} ${*}$@>
@z

@x [288]
@d wait_or_pass(t) if (data->i==prego) {@+pass_after(t);@+goto passit;@+}
@y
@d wait_or_pass(t) if (data->i==prego) {@+pass_after(t);@+goto passit;@+}
@-t@> @% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [289]
@ @<Handle special cases for operations like |prego| and |ldvts|@>=
@y
@ @<Handle special cases for operations like |prego| and |ldvts|@>=
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [291]
@ @d got_IT 19   /* |state| when IT-cache entry has been computed */
@y
@r @ @d got_IT 19   /* |state| when IT-cache entry has been computed */
@% @$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [292]
@<Do a simultaneous lookup in the I-cache@>=
@y
@<Do a simultaneous lookup in the I-cache@>=
@% @$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@$q {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [293]
p=use_and_fix(ITcache,p);
@y
p=use_and_fix(ITcache,p);
@% @$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [294]
@ At this point |inst_ptr.o| equals |data->y.o|.
@y
@ At this point |inst_ptr.o| equals |data->y.o|.
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$q {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [295]
@ @<Begin fetch without I-cache lookup@>=
@y
@ @<Begin fetch without I-cache lookup@>=
@% @$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [296]
@ @<Begin fetch with known physical address@>=
@y
@ @<Begin fetch with known physical address@>=
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$q {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [298]
@ @<Other cases for the fetch coroutine@>=
@y
@ @<Other cases for the fetch coroutine@>=
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [300]
@ @<Try to get the contents of location |data->z.o| in the I-cache@>=
@y
@r @ @<Try to get the contents of location |data->z.o| in the I-cache@>=
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$q {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [301]
@<Other cases for the fetch coroutine@>=
@y
@<Other cases for the fetch coroutine@>=
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [304]
@ At this point we check for egregiously invalid instructions. (Sometimes
@y
@r @ At this point we check for egregiously invalid instructions. (Sometimes
@z

@x [307]
@<Handle interrupt at end of execution stage@>=
@y
@<Handle interrupt at end of execution stage@>=
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [308]
@ Since execution is speculative, an exceptional condition might not
@y
@r @ Since execution is speculative, an exceptional condition might not
@z
@x [308]
{@+register int m;
@y
{@+register int m; @-m@>
@z

@x [310]
    if (is_load_store(data->i)) nullifying=true;
@y
    if (is_load_store(data->i)) nullifying=true;
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [312]
@ @<Special cases of instruction dispatch@>=
@y
@ @<Special cases of instruction dispatch@>=
@%
@$a {MMIX-PIPE}44 \&{specnode}@>
@$b {MMIX-PIPE}44 \&{spec}@>
@z

@x [313]
@ @<Cases for stage 1 execution@>=
@y
@ @<Cases for stage 1 execution@>=
@%
@$a {MMIX-PIPE}44 \&{specnode}@>
@$b {MMIX-PIPE}44 \&{spec}@>
@z

@x [314]
@ The following check is performed at the beginning of every cycle.
@y
@r @ The following check is performed at the beginning of every cycle.
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [316]
@<Deissue all but the hottest command@>=
@y
@<Deissue all but the hottest command@>=
@%
@$i {MMIX-PIPE}12 \&{register} \&{int}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [317]
@<Begin an interruption and |break|@>=
@y
@<Begin an interruption and |break|@>=
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [319]
@ @<Set resumption registers $\rm(rB,\$255)$ or $\rm(rBB,\$255)$@>=
@y
@r @ @<Set resumption registers $\rm(rB,\$255)$ or $\rm(rBB,\$255)$@>=
@z

@x [320]
@d pack_bytes(a,b,c,d) ((((((byte)(a)<<8)+(b))<<8)+(c))<<8)+(d)
@y
@d pack_bytes(a,b,c,d) ((((((byte)(a)<<8)+(b))<<8)+(c))<<8)+(d)
@-a@> @-b@> @-c@> @-d@>
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [321]
@ @<Set resumption registers $\rm(rY,rZ)$ or $\rm(rYY,rZZ)$@>=
@y
@r @ @<Set resumption registers $\rm(rY,rZ)$ or $\rm(rYY,rZZ)$@>=
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [322]
      cool->ren_a=true, spec_install(&g[rK],&cool->a);
      cool->a.known=true, cool->a.o=g[255].o;
      cool->ren_x=true, spec_install(&g[255],&cool->x);
      cool->x.known=true, cool->x.o=g[rBB].o;
@y
      cool->ren_a=true; spec_install(&g[rK],&cool->a);
      cool->a.known=true; cool->a.o=g[255].o;
      cool->ren_x=true; spec_install(&g[255],&cool->x);
      cool->x.known=true; cool->x.o=g[rBB].o;
@%
@$a {MMIX-PIPE}44 \&{specnode}@>
@$b {MMIX-PIPE}44 \&{spec}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [323]
{@+register int m;
@y
{@+register int m;
@-m@>
@%
@$b {MMIX-PIPE}44 \&{spec}@>
@z

@x [325]
@ @d do_resume_trans 17 /* |state| for performing |RESUME_TRANS| actions */
@y
@ @d do_resume_trans 17 /* |state| for performing |RESUME_TRANS| actions */
@% @$b {MMIX-PIPE}44 \&{spec}@>
@z

@x [326]
case do_resume_trans: resume_trans: {@+register cache*c=(cache*)data->ptr_a;
@y
case do_resume_trans: resume_trans: {@+register cache*c=(cache*)data->ptr_a;
@-c@>
@%
@$b {MMIX-PIPE}44 \&{spec}@>
@$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [327]
@<Cases for stage 1 execution@>=
@y
@<Cases for stage 1 execution@>=
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [331]
@ Computed jumps put the desired destination address into the |go| field.
@y
@ Computed jumps put the desired destination address into the |go| field.
@% @$b {MMIX-PIPE}44 \&{spec}@>
@z

@x [332]
@ The instruction \.{UNSAVE} $z$ generates a sequence of internal instructions
@y
@r @ The instruction \.{UNSAVE} $z$ generates a sequence of internal instructions
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [334]
@ @<Set up the first phase of unsaving@>=
@y
@ @<Set up the first phase of unsaving@>=
@% @$a {MMIX-PIPE}44 \&{specnode}@>
@z

@x [336]
@ @<Handle an internal \.{UNSAVE} when it's time to load@>=
@y
@ @<Handle an internal \.{UNSAVE} when it's time to load@>=
@% @$a {MMIX-PIPE}44 \&{specnode}@>
@z

@x [337]
@ Of course \.{SAVE} is handled essentially like \.{UNSAVE}, but backwards.
@y
@r @ Of course \.{SAVE} is handled essentially like \.{UNSAVE}, but backwards.
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z
@x [337]
 case 0: @<Set up the first phase of saving@>;@+break;
@y
 case 0: @<Set up the first phase of saving@>; break;
@z
@x [337]
 case 2: case 3: @<Generate an instruction to save |g[yy]|@>;@+break;
@y
 case 2: case 3: @<Generate an instruction to save |g[yy]|@>; break;
@z

@x [339]
@ @<Generate an instruction to save |g[yy]|@>=
@y
@ @<Generate an instruction to save |g[yy]|@>=
@% @$b {MMIX-PIPE}44 \&{spec}@>
@z

@x [340]
@<Do the final \.{SAVE}@>=
@y
@<Do the final \.{SAVE}@>=
@%
@$a {MMIX-PIPE}44 \&{specnode}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [342]
@ @<Handle an internal \.{SAVE} when it's time to store@>=
@y
@ @<Handle an internal \.{SAVE} when it's time to store@>=
@%
@$a {MMIX-PIPE}44 \&{specnode}@>
@$b {MMIX-PIPE}44 \&{spec}@>
@z

@x [343]
@<Cases to compute the results of reg...@>=
@y
@<Cases to compute the results of reg...@>=
@%
@$a {MMIX-PIPE}44 \&{specnode}@>
@$b {MMIX-PIPE}44 \&{spec}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [345]
@<Cases to compute the results...@>=
@y
@<Cases to compute the results...@>=
@% @$b {MMIX-PIPE}44 \&{spec}@>
@z

@x [346]
@d ROUND_NEAR 4
@y
@d ROUND_NEAR 4
@t}\ifx\undefined\eightpoint\else\vskip1cm\fi{@>
@-x@>
@%
@$a {MMIX-PIPE}44 \&{specnode}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [348]
@ @<Cases to compute the results of reg...@>=
@y
@ @<Cases to compute the results of reg...@>=
@%
@$b {MMIX-PIPE}44 \&{spec}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [351]
@ @<Begin execution of a stage-two operation@>=
@y
@r @ @<Begin execution of a stage-two operation@>=
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [352]
@<Handle special cases for operations like |prego| and |ldvts|@>=
@y
@<Handle special cases for operations like |prego| and |ldvts|@>=
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [353]
@ @<Do stage 1 of \.{LDVTS}@>=
@y
@ @<Do stage 1 of \.{LDVTS}@>=
@% @$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [354]
@ @<Special cases for states in later stages@>=
@y
@ @<Special cases for states in later stages@>=
@% @$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [357]
for (control* cc=data;cc!=hot;) {
@y
for (control* cc=data;cc!=hot;) {
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [359]
if (!Icache) {
  data->state=11;@+goto switch1;
@y
if (!Icache) { @+
  data->state=11;@+goto switch1; @+
@z

@x [361]
@ @<Clean the \9{a}data caches@>=
@y
@ @<Clean the \9{a}data caches@>=
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [364]
 if (!Icache) {
   data->state=(data->loc.h&sign_bit? 31:33);@+goto switch2;
@y
 if (!Icache) { @+
   data->state=(data->loc.h&sign_bit? 31:33);@+goto switch2; @+
@%
@$b {MMIX-PIPE}44 \&{spec}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z
@x [364]
   { if (data->i==syncd) goto fin_ex;@+ else goto next_sync; }
@y
   { if (data->i==syncd) goto fin_ex; else goto next_sync; }
@z

@x [365]
p=cache_search(Icache,data->z.o);
if (p) {
@y
if (p=cache_search(Icache,data->z.o)) {
@% @$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [366]
p=cache_search(Dcache,data->z.o);
if (p) {
@y
if (p=cache_search(Dcache,data->z.o)) {
@% @$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [367]
p=cache_search(Scache,data->z.o);
if (p) {
@y
if (p=cache_search(Scache,data->z.o)) {
@% @$p {MMIX-PIPE}125 \&{register} \&{cacheblock} ${*}$@>
@z

@x [368]
@ @<Use |cleanup| on the cache blocks for |data->z.o|, if any@>=
@y
@ @<Use |cleanup| on the cache blocks for |data->z.o|, if any@>=
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [369]
@<Continue this command on the next cache block@>=
@y
@<Continue this command on the next cache block@>=
@%
@$b {MMIX-PIPE}44 \&{spec}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [373]
else if (zz==1) {
  octa trap_loc=incr(g[rWW].o,-4);
@y
else if (zz==1) { @+
  octa trap_loc=incr(g[rWW].o,-4); @+@t}\6{@>
@z

@x [374]
static char arg_count[]={1,3,1,3,3,3,3,2,2,2,1};
@y
@+ static char arg_count[]={1,3,1,3,3,3,3,2,2,2,1};
@z

@x [378]
    if (((Dcache->outbuf.tag.l^addr.l)&-Dcache->bb)==0 &&
@y
    if (((Dcache->outbuf.tag.l^addr.l)&-Dcache->bb)==0 && @|
@-p@> @-q@>
@z
@x [378]
      if (((Scache->outbuf.tag.l^addr.l)&-Scache->bb)==0 &&
@y
      if (((Scache->outbuf.tag.l^addr.l)&-Scache->bb)==0 && @|
@z

@x [379]
    if (((Dcache->inbuf.tag.l^addr.l)&-Dcache->bb)==0 &&
@y
    if (((Dcache->inbuf.tag.l^addr.l)&-Dcache->bb)==0 && @|
@z
@x [379]
    if (((Dcache->outbuf.tag.l^addr.l)&-Dcache->bb)==0 &&
@y
    if (((Dcache->outbuf.tag.l^addr.l)&-Dcache->bb)==0 && @|
@z
@x [379]
      if (((Scache->inbuf.tag.l^addr.l)&-Scache->bb)==0 &&
@y
      if (((Scache->inbuf.tag.l^addr.l)&-Scache->bb)==0 && @|
@z
@x [379]
      if (((Scache->outbuf.tag.l^addr.l)&-Scache->bb)==0 &&
@y
      if (((Scache->outbuf.tag.l^addr.l)&-Scache->bb)==0 && @|
@z

@x [381]
@ The subroutine |mmgetchars(buf,size,addr,stop)| reads characters
@y
@r @ The subroutine |mmgetchars(buf,size,addr,stop)| reads characters
@z

@x [384]
  register unsigned char *p;
@y
  @+ register unsigned char *p;
@z

@x [385]
  register int s=8*((~a.l)&0x3);
@y
  @+ register int s=8*((~a.l)&0x3);
@z

@x [389]
read from and write to the memory-mapped addresses.
@y
read from and write to the memory-mapped addresses.
@-size@>
@z

@x [391]
@ The default |spec_write| just reports its arguments, without actually
@y
@r @ The default |spec_write| just reports its arguments, without actually
@z
