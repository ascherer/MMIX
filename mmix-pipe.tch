@x [0]
\input pdfwebtocfront
@y
\pdfpagewidth=\pagewidth \advance\pdfpagewidth by 1in
\pdfpageheight=\fullpageheight \advance\pdfpageheight by 1in
\ifpdflua \pdfhorigin=0.5in \pdfvorigin=0.5in
\else \global\pageshift=-0.5in
  \global\hoffset=-0.5in \global\voffset=-0.5in \fi

\ifx\undefined\eightpoint\else
{\eightpoint \let\ninett=\eighttt \editorsnote \vskip7mm}
\fi
@z

@x [5]
@(mmix-pipe.h@>=
@y
@-MMIX_PIPE_H@>
@(mmix-pipe.h@>=
@z

@x [7]
@ Some of the names that are natural for this program are in
@y
@r @ Some of the names that are natural for this program are in
@z
@x [7]
bypass the library names here.
@y
bypass the library names here.
@-my_div@> @-my_fsqrt@> @-my_random@>
@z

@x [12]
@ @<Local var...@>=
@y
@r @ @<Local var...@>=
@z

@x [13}
@d confusion(m) errprint("This can't happen: %s",m)
@y
@d confusion(m) errprint("This can't happen: %s",m)
@-x@> @-m@>
@z

@x [19]
static void print_octa(
@y
static void print_octa(
@-o@>
@z

@x [21]
the remainder in~|aux|.
@y
the remainder in~|aux|.
@-y@> @-z@>
@z

@x [26]
@ Coroutine control is masterminded by a ring of queues, one each for
@y
@r @ Coroutine control is masterminded by a ring of queues, one each for
@z
@x [26]
etc., from back to front, and we have |c->stage<=c->next->stage| unless |c=h|.
@y
etc., from back to front, and we have |c->stage<=c->next->stage| unless |c=h|.
@-c@> @-h@> @-p@>
@z
@x [26]
@<Initialize e...@>=@+
@y
@<Initialize e...@>=
@z

@x [27]
|schedule(c,d,s)|. (The |s| parameter is used only if scheduling is
@y
the function |schedule(c,d,s)|. (The |s| parameter is used only if scheduling is
@z
@x [27]
generally set |s| to the state at which the scheduled coroutine will begin.)
@y
generally set |s| to the state at which the scheduled coroutine will begin.)
@-c@> @-d@> @-s@>
@z

@x [28]
static void schedule(
@y
static void schedule(
@-p@>
@z

@x [32]
coroutine is not assumed to have any valid data in its |ctl| field.
@y
coroutine is not assumed to have any valid data in its |ctl| field.
@-c@>
@z

@x [33]
static void unschedule(
@y
static void unschedule(
@-p@>
@z

@x [34]
of Computer Programming}.
@y
of Computer Programming}.
@-t@>
@z

@x [35]
static coroutine *queuelist(int);

@ @<Sub...@>=
@y
static coroutine *queuelist(int);

@r @ @<Sub...@>=
@z

@x [37]
@d release_lock(c,l) {@+l=NULL;@+ (c)->lockloc=NULL;@+}
@y
@d release_lock(c,l) {@+l=NULL;@+ (c)->lockloc=NULL;@+}
@-c@> @-l@>
@z

@x [48]
@!POP,@!RESUME,@!SAVE,@!UNSAVE,@!SYNC,@!SWYM,@!GET,@!TRIP}@+@!mmix_opcode;

@ @<Glob...@>=
@y
@!POP,@!RESUME,@!SAVE,@!UNSAVE,@!SYNC,@!SWYM,@!GET,@!TRIP}@+@!mmix_opcode;

@r @ @<Glob...@>=
@z

@x [49]
@!or, /* \.{OR[I]}, \.{OR[M][H,L]} */
@y
@!or, /* \.{OR[I]}, \.{OR[M][H,L]} */ @+ @t\qquad@>
@z
@x [49]
@!nor, /* \.{NOR[I]} */
@y
@!nor, /* \.{NOR[I]} */ @+ @t\qquad@>
@z
@x [49]
@!andn, /* \.{ANDN[I]}, \.{ANDN[M][H,L]} */
@y
@!andn, /* \.{ANDN[I]}, \.{ANDN[M][H,L]} */ @+ @t\qquad@>
@z
@x [49]
@!xor, /* \.{XOR[I]} */
@y
@!xor, /* \.{XOR[I]} */ @+ @t\qquad@>
@z
@x [49]
@!go, /* \.{GO[I]} */
@y
@!go, /* \.{GO[I]} */
@-go@>
@z
@x [49]
@!save, /* \.{SAVE} */
@y
@!save, /* \.{SAVE} */ @+ @t\qquad@>
@z
@x [49]
@!trap, /* \.{TRAP} */
@y
@!trap, /* \.{TRAP} */ @+ @t\qquad@>
@z

@x [50]
static char *internal_op_name[]={
@y
static char *internal_op_name[]={@|
@z
@x [50]
"mul8",
@y
"mul8",@|
@z
@x [50]
"fsqrt",
@y
"fsqrt",@|
@z
@x [50]
"frem",
@y
"frem",@|
@z
@x [50]
"set",
@y
"set",@|
@z
@x [50]
"nxor",
@y
"nxor",@|
@z
@x [50]
"odif",
@y
"odif",@|
@z
@x [50]
"ldvts",
@y
"ldvts",@|
@z
@x [50]
"cswap",
@y
"cswap",@|
@z
@x [50]
"resume",
@y
"resume",@|
@z
@x [50]
"trip",
@y
"trip",@|
@z

@x [51]
internal ones.
@y
internal ones.
@-go@> @% @$go {MMIX-PIPE}49 =72@>
@z

@x [53]
static char *special_name[32]={"rB","rD","rE","rH","rJ","rM","rR","rBB",
 "rC","rN","rO","rS","rI","rT","rTT","rK","rQ","rU","rV","rG","rL",
 "rA","rF","rP","rW","rX","rY","rZ","rWW","rXX","rYY","rZZ"};
@y
static char *special_name[32]={@|"rB","rD","rE","rH","rJ","rM","rR","rBB",@|
 "rC","rN","rO","rS","rI","rT","rTT","rK",@|"rQ","rU","rV","rG","rL",
 "rA","rF","rP",@|"rW","rX","rY","rZ","rWW","rXX","rYY","rZZ"};
@z

@x [54]
@ Here are the bit codes that affect trips and traps. The first eight
@y
@r @ Here are the bit codes that affect trips and traps. The first eight
@z

@x [56]
  for (int j=0,b=E_BIT;(x&(b+b-1))&&b;j++,b>>=1)
@y
  for (int j=0,b=E_BIT;(x&(b+b-1))&&b;j++,b>>=1)
@-x@> @-b@> @-j@>
@z

@x [59]
reorder buffer.
@y
reorder buffer.
@-b@> @-x@> @-y@> @-z@>
@z

@x [61]
hot=cool=reorder_top;
@y
hot=cool=reorder_top; @+
@z

@x [63]
    for (control* p=hot;p!=cool; p=(p==reorder_bot? reorder_top: p-1)) {
@y
    for (control* p=hot;p!=cool; p=(p==reorder_bot? reorder_top: p-1)) {
@-p@>
@z

@x [67]
@ @<Commit and/or deissue up to |commit_max| instructions@>=
@y
@ @<Commit and/or deissue up to |commit_max| instructions@>=
@%
@$i {MMIX-PIPE}12 \&{register} \&{int}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [71]
@ @d UNKNOWN_SPEC ((specnode*)1)
@y
@ @d UNKNOWN_SPEC ((specnode*)1)
@z

@x [73]
static void print_fetch_buffer(void)
@y
@-p@> @% @$p {MMIX-PIPE}73 \&{fetch} ${*}$@>
static void print_fetch_buffer(void)
@z

@x [75]
  register mmix_opcode op;
@y
  register mmix_opcode op; @-op@>
@z

@x [78]
@ It is convenient to have
@y
@r @ It is convenient to have
@z

@x [79]
  for (i=0;i<8;i++) support[i] |= u->ops[i];
@y
  for (i=0;i<8;i++) support[i] |= u->ops[i];
@-u@> @$i {MMIX-PIPE}12 \&{register} \&{int}@>
@z

@x [80]
@ @<Determine the flags, |f|, and the internal opcode, |i|@>=
@y
@ @<Determine the flags, |f|, and the internal opcode, |i|@>=
@% @$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [81]
@ @<Issue the |cool| instruction@>=
@y
@ @% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@<Issue the |cool| instruction@>=
@z

@x [82]
functional unit that supports |op| and has stage~1 unoccupied.
@y
functional unit that supports |op| and has stage~1 unoccupied.
@-t@> @-b@> @%
@$i {MMIX-PIPE}12 \&{register} \&{int}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [84]
@ @<Convert relative...@>=
{
@y
@ @<Convert relative...@>=
{ @+
@% @$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z
@x [84]
  cool->z.o=incr(head->loc,yz<<2), cool->z.p=NULL;
@y
  cool->z.o=incr(head->loc,yz<<2), cool->z.p=NULL; @+
@z

@x [85]
is made in the common case that the speculative value of~rJ is known.
@y
is made in the common case that the speculative value of~rJ is known.
@% @$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [86]
rB is internally the same as g[0], because |rB=0|.
@y
rB is internally the same as g[0], because |rB=0|.
@-a@> @-x@>
@z

@x [89]
@ The |addr| fields in the specnode lists for registers are used
to identify that register in diagnostic messages. Such addresses
@y
@ The |addr| fields in the specnode lists are used
to identify the register in diagnostic messages. Such addresses
@z
@x [89]
@d SUBSUBVERSION 2 /* further qualification to version number */
@y
@d SUBSUBVERSION 2 /* further qualification to version number */
@%
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@z

@x [91]
static void print_specnode_id(
@y
@-a@> @%
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
static void print_specnode_id(
@z

@x [94]
static void spec_install(specnode*,specnode*);
@y
static void spec_install(specnode*,specnode*);
@-spec_install@>
@z

@x [95]
static void spec_install( /* insert |t| into list |r| */
@y
@-spec_install@>
static void spec_install( /* insert |t| into list |r| */
@z

@x [96]
static void spec_rem(specnode*);

@ @<Sub...@>=
@y
static void spec_rem(specnode*);
@-spec_rem@>

@ @<Sub...@>=
@-spec_rem@>
@z

@x [100]
@ @<Install default fields in the |cool| block@>=
@y
@ @<Install default fields in the |cool| block@>=
@%
@$i {MMIX-PIPE}12 \&{register} \&{int}@>
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$op {MMIX-PIPE}44 \&{mmix\_opcode}@>
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [102]
have been unsaved, so we aren't fussy about it here.
@y
have been unsaved, so we aren't fussy about it here.
@$l {MMIX-ARITH}3 \&{tetra}@>
@%
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [103]
@ @<Install the operand fields of the |cool| block@>=
@y
@ @<Install the operand fields of the |cool| block@>=
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [104]
@ @<Set \9{c}|cool->z| from register Z@>=
@y
@ @<Set \9{c}|cool->z| from register Z@>=
@%
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@z

@x [105]
@ @<Set \9{c}|cool->y| from register Y@>=
@y
@ @<Set \9{c}|cool->y| from register Y@>=
@%
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@z

@x [106]
@ @<Set \9{c}|cool->b| from register X@>=
@y
@ @<Set \9{c}|cool->b| from register X@>=
@%
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@z

@x [108]
@<Set \9{c}|cool->b| and/or |cool->ra| from special register@>=
@y
@<Set \9{c}|cool->b| and/or |cool->ra| from special register@>=
@% @$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [109]
@ @<Set \9{c}|cool->z| as an immediate wyde@>=
@y
@r @ @<Set \9{c}|cool->z| as an immediate wyde@>=
@% @$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [110]
@ @<Install register X...@>=
@y
@ @<Install register X...@>=
@%
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@z

@x [112]
in the ring of local registers.
@y
in the ring of local registers.
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [113]
@<Insert \9{a}an instruction to advance gamma@>=
@y
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@<Insert \9{a}an instruction to advance gamma@>=
@z

@x [114]
@ The |decgamma| instruction decreases $\gamma$ and rS by loading an octabyte
@y
@r @ @%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
The |decgamma| instruction decreases $\gamma$ and rS by loading an octabyte
@z
@x [114]
  cool->z=cool->b=zero_spec; cool->need_b=false;
@y
  cool->z=cool->b=zero_spec; @+ cool->need_b=false;
@z

@x [117]
from memory before they write it.
@y
from memory before they write it.
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [118]
@ When new data is \.{PUT} into special registers 8 or 15--20 (namely rC, rK,
rQ, rU, rV, rG, or~rL) it can affect many things. Therefore we stop
@y
@ When new data is \.{PUT} into special registers 8 or 15--20 (namely |rC|, |rK|,
|rQ|, |rU|, |rV|, |rG|, or~|rL|) it can affect many things. Therefore we stop
@z
@x [118]
they reach the hot seat.
@y
they reach the hot seat.
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [119]
insert an~|incrl| command.
@y
insert an~|incrl| command.
@-x@>
@%
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@z

@x [120]
in order to maintain the condition $\rm rS\le rO$.
@y
in order to maintain the condition $\rm rS\le rO$.
@-x@> @-p@>
@%
@$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$l {MMIX-ARITH}3 \&{tetra}@>
@$l {MMIX-PIPE}86 \&{Extern} \&{specnode} ${*}$@>
@z

@x [122]
when the page table method isn't implemented in hardware.
@y
when the page table method isn't implemented in hardware.
\vskip1in
@z

@x [124]
typically have |data->state=0| when a coroutine is first fired~up.
@y
typically have |data->state=0| when a coroutine is first fired~up.
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [125]
    print_control_block(data);@+printf("\n");
  }
@y
    print_control_block(data);@+printf("\n"); @+
  }
@-c@> @-t@>
@z

@x [131]
if (data->y.p) {
@y
if (data->y.p) { @+
@z
@x [131]
if (data->z.p) {
@y
if (data->z.p) { @+
@z
@x [131]
if (data->b.p) {
@y
if (data->b.p) { @+
@z
@x [131]
if (data->ra.p) {
@y
if (data->ra.p) { @+
@z

@x [132]
the proper time.
@y
the proper time.
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [133]
added to~$t_k$.
@y
added to~$t_k$.
@-s@> @% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [134]
unit is |self+1|.
@y
unit is |self+1|.
@-s@> @% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [138]
@ Here are the basic boolean operations, which account for 24 of \MMIX's
@y
@r @ Here are the basic boolean operations, which account for 24 of \MMIX's
@z
@x [138]
case or: data->x.o=oor(data->y.o, data->z.o); @+ break;
case orn: data->x.o=oorn(data->y.o, data->z.o); @+ break;
case nor: data->x.o=onor(data->y.o, data->z.o); @+ break;
case and: data->x.o=oand(data->y.o, data->z.o); @+ break;
case andn: data->x.o=oandn(data->y.o, data->z.o); @+ break;
case nand: data->x.o=onand(data->y.o, data->z.o); @+ break;
case xor: data->x.o=oxor(data->y.o, data->z.o); @+ break;
case nxor: data->x.o=onxor(data->y.o, data->z.o); @+ break;
@y
case or: data->x.o=oor(data->y.o, data->z.o); break;
case orn: data->x.o=oorn(data->y.o, data->z.o); break;
case nor: data->x.o=onor(data->y.o, data->z.o); break;
case and: data->x.o=oand(data->y.o, data->z.o); break;
case andn: data->x.o=oandn(data->y.o, data->z.o); break;
case nand: data->x.o=onand(data->y.o, data->z.o); break;
case xor: data->x.o=oxor(data->y.o, data->z.o); break;
case nxor: data->x.o=onxor(data->y.o, data->z.o); break;
@z

@x [139]
case subu: data->x.o=ominus(data->y.o,data->z.o);@+ break;
@y
case subu: data->x.o=ominus(data->y.o,data->z.o); break;
@z

@x [141]
below.)
@y
below.)
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [144]
@ The other operations will be deferred until later, now that we understand
@y
@r @ The other operations will be deferred until later, now that we understand
@z

@x [145]
  cool_O=cool->cur_O;@+ cool_S=cool->cur_S;
@y
  cool_O=cool->cur_O;@+ cool_S=cool->cur_S; @+
@z

@x [146]
@ @<Commit the hottest instruction...@>=
@y
@ @<Commit the hottest instruction...@>=
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [149]
  }@+else if ((g[rK].o.h&0xff)!=0xff && !(hot->interrupt&S_BIT)) {
@y
  }@+else @/ if ((g[rK].o.h&0xff)!=0xff && !(hot->interrupt&S_BIT)) {
@z

@x [151]
don't want to update it yet.
@y
don't want to update it yet.
@% @$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [152]
@ We update the |bp_table| when an instruction is issued.
@y
@r @ We update the |bp_table| when an instruction is issued.
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@$op {MMIX-PIPE}75 \&{register} \&{mmix\_opcode}@>
@z

@x [155]
prediction was correct or not.
@y
prediction was correct or not.
@% @$i {MMIX-PIPE}44 \&{internal\_opcode}@>
@z

@x [160]
@ If more than one functional unit is able to process branch instructions and
@y
@r @ If more than one functional unit is able to process branch instructions and
@z

@x [170]
static bool is_dirty(cache*,cacheblock*);

@ @<Sub...@>=
@y
static bool is_dirty(cache*,cacheblock*);

@r @ @<Sub...@>=
@z

@x [185]
  for (int j=0,jj=off>>c->g;j<c->bb>>c->g;j++,jj++) if (p->dirty[j]) {
@y
  for (int j=0,jj=off>>c->g;j<c->bb>>c->g;j++,jj++) if (p->dirty[j]) {
@-j@> @-jj@>
@z
@x [185]
    for (int i=j<<(c->g-3),ii=jj<<(c->g-3),lim=(j+1)<<(c->g-3);
@y
    for (int i=j<<(c->g-3),ii=jj<<(c->g-3),lim=(j+1)<<(c->g-3);
@-i@> @-ii@> @-lim@>
@z

@x [213]
Extern void mem_write(octa addr,octa val);

@ @<External r...@>=
@y
Extern void mem_write(octa addr,octa val);

@r @ @<External r...@>=
@z

@x [217]
                   /* |p| not moved */
@y
@z

@x [218]
p=alloc_slot(Scache,c->outbuf.tag);
@y
p=alloc_slot(Scache,c->outbuf.tag); @+
@z

@x [225]
p=alloc_slot(Scache,data->z.o);
@y
p=alloc_slot(Scache,data->z.o); @+
@z
@x [224]
set_lock(&Scache->filler,mem_lock);
@y
set_lock(&Scache->filler,mem_lock); @+
@z

@x [227]
\dots, into the cache if it is not too busy.

@y
\dots, into the cache if it is not too busy.
@z

@x [235]
  if (!is_dirty(Scache,p)) {
    p->tag.h|=data->x.o.h;@+goto Sclean_inc;
@y
  if (!is_dirty(Scache,p)) { @+
    p->tag.h|=data->x.o.h;@+goto Sclean_inc; @+
@z

@x [236]
static char *DPTname[5]={"DPT0","DPT1","DPT2","DPT3","DPT4"};

@ @<Initialize e...@>=
@y
static char *DPTname[5]={"DPT0","DPT1","DPT2","DPT3","DPT4"};

@r @ @<Initialize e...@>=
@z

@x [238]
convenience. Whenever rV changes, we recompute all these variables.
@y
convenience. Whenever rV changes, we recompute all these variables.
@-b@> @-f@> @-n@> @-r@> @-s@>
@z

@x [239]
@ @<Update the \\{page} variables@>=
@y
@r @ @<Update the \\{page} variables@>=
@z
@x [239]
  page_n=rv.l&0x1ff8;
@y
  page_n=rv.l&0x1ff8; @+
@z
@x [239]
  page_r=rv.l&0x7ffffff;
@y
  page_r=rv.l&0x7ffffff; @+
@z
@x [239]
  page_b[4]=(rv.l>>8)&0xf;
@y
  page_b[4]=(rv.l>>8)&0xf; @+
@z
@x [239}
  page_b[2]=(rv.l>>16)&0xf;
@y
  page_b[2]=(rv.l>>16)&0xf; @+
@z

@x [245]
@ At this point the translation of the given virtual address |data->y.o| is
@y
@r @ At this point the translation of the given virtual address |data->y.o| is
@z

@x [251[
static void print_write_buffer(void);

@ @<Sub...@>=
@y
static void print_write_buffer(void);

@r @ @<Sub...@>=
@z

@x [256]
@<Commit to memory...@>=
{@+register write_node *q=write_tail;
@y
@<Commit to memory...@>=
{ register write_node *q=write_tail;
@z

@x [259]
(see |MMIX_config|). Although an uncached store will not be stored in the
@y
(see function |MMIX_config|). Although an uncached store will not be stored in the
@z

@x [260]
set_lock(&mem_locker,mem_lock); /* a coroutine of type |vanish| */
@y
@+ set_lock(&mem_locker,mem_lock); /* a |vanish| coroutine */
@z

@x [261]
if (Scache) set_lock(&Dcache->filler,Scache->lock)@;
else set_lock(&Dcache->filler,mem_lock);
@y
set_lock(&Dcache->filler, Scache ? Scache->lock : mem_lock);
@z
@x [261]
set_lock(self,Dcache->fill_lock);
data->ptr_b=Dcache->filler_ctl.ptr_b=(void *)p;
Dcache->filler_ctl.z.o=write_head->addr;
@y
set_lock(self,Dcache->fill_lock); @+
Dcache->filler_ctl.z.o=write_head->addr;
data->ptr_b=Dcache->filler_ctl.ptr_b=(void *)p;
@z

@x [265]
  data->z.o=incr(data->z.o,data->xx&-(data->i==prego? Icache: Dcache)->bb);
  /* (I hope the adder is fast enough) */
@y
  /* (I hope the adder is fast enough) */
  data->z.o=incr(data->z.o,data->xx&-(data->i==prego? Icache: Dcache)->bb);
@z

@x [268]
If the lower $b+c$ bits of the virtual and physical addresses differ,
@y
\vskip1cm
If the lower $b+c$ bits of the virtual and physical addresses differ,
@z

@x [271]
@ @<Do load/store stage 1 with known physical address@>=
{@+octa *m;
@y
@ @<Do load/store stage 1 with known physical address@>=
{octa *m;
@z
@x [271]
    data->state=st_ready;@+pass_after(1);@+goto passit;
@y
    data->state=st_ready; pass_after(1);@+goto passit;
@z
@x [271]
    data->state=DT_hit;@+pass_after(1);@+ goto passit;
@y
    data->state=DT_hit; pass_after(1);@+ goto passit;
@z

@x [273]
@ The second stage might also want to fill the D-cache (and perhaps
@y
@r @ The second stage might also want to fill the D-cache (and perhaps
@z

@x [291]
@ @d got_IT 19   /* |state| when IT-cache entry has been computed */
@y
@r @ @d got_IT 19   /* |state| when IT-cache entry has been computed */
@z

@x [300]
@ @<Try to get the contents of location |data->z.o| in the I-cache@>=
@y
@r @ @<Try to get the contents of location |data->z.o| in the I-cache@>=
@z

@x [304]
@ At this point we check for egregiously invalid instructions. (Sometimes
@y
@r @ At this point we check for egregiously invalid instructions. (Sometimes
@z

@x [308]
@ Since execution is speculative, an exceptional condition might not
@y
@r @ Since execution is speculative, an exceptional condition might not
@z

@x [314]
@ The following check is performed at the beginning of every cycle.
@y
@r @ The following check is performed at the beginning of every cycle.
@z

@x [319]
@ @<Set resumption registers $\rm(rB,\$255)$ or $\rm(rBB,\$255)$@>=
@y
@r @ @<Set resumption registers $\rm(rB,\$255)$ or $\rm(rBB,\$255)$@>=
@z

@x [321]
@ @<Set resumption registers $\rm(rY,rZ)$ or $\rm(rYY,rZZ)$@>=
@y
@r @ @<Set resumption registers $\rm(rY,rZ)$ or $\rm(rYY,rZZ)$@>=
@z

@x [322]
      cool->ren_a=true, spec_install(&g[rK],&cool->a);
      cool->a.known=true, cool->a.o=g[255].o;
      cool->ren_x=true, spec_install(&g[255],&cool->x);
      cool->x.known=true, cool->x.o=g[rBB].o;
@y
      cool->ren_a=true; spec_install(&g[rK],&cool->a);
      cool->a.known=true; cool->a.o=g[255].o;
      cool->ren_x=true; spec_install(&g[255],&cool->x);
      cool->x.known=true; cool->x.o=g[rBB].o;
@z

@x [332]
@ The instruction \.{UNSAVE} $z$ generates a sequence of internal instructions
@y
@r @ The instruction \.{UNSAVE} $z$ generates a sequence of internal instructions
@z

@x [337]
@ Of course \.{SAVE} is handled essentially like \.{UNSAVE}, but backwards.
@y
@r @ Of course \.{SAVE} is handled essentially like \.{UNSAVE}, but backwards.
@z
@x [337]
 case 0: @<Set up the first phase of saving@>;@+break;
@y
 case 0: @<Set up the first phase of saving@>; break;
@z
@x [337]
 case 2: case 3: @<Generate an instruction to save |g[yy]|@>;@+break;
@y
 case 2: case 3: @<Generate an instruction to save |g[yy]|@>; break;
@z

@x [346]
@d ROUND_NEAR 4
@y
@d ROUND_NEAR 4
@t}\vskip1cm{@>
@z

@x [351]
@ @<Begin execution of a stage-two operation@>=
@y
@r @ @<Begin execution of a stage-two operation@>=
@z

@x [359]
if (!Icache) {
  data->state=11;@+goto switch1;
@y
if (!Icache) { @+
  data->state=11;@+goto switch1; @+
@z

@x [364]
 if (!Icache) {
   data->state=(data->loc.h&sign_bit? 31:33);@+goto switch2;
@y
 if (!Icache) { @+
   data->state=(data->loc.h&sign_bit? 31:33);@+goto switch2; @+
@z
@x [364]
   { if (data->i==syncd) goto fin_ex;@+ else goto next_sync; }
@y
   { if (data->i==syncd) goto fin_ex; else goto next_sync; }
@z

@x [365]
p=cache_search(Icache,data->z.o);
if (p) {
@y
if (p=cache_search(Icache,data->z.o)) {
@z

@x [366]
p=cache_search(Dcache,data->z.o);
if (p) {
@y
if (p=cache_search(Dcache,data->z.o)) {
@z

@x [367]
p=cache_search(Scache,data->z.o);
if (p) {
@y
if (p=cache_search(Scache,data->z.o)) {
@z

@x [373]
else if (zz==1) {
  octa trap_loc=incr(g[rWW].o,-4);
@y
else if (zz==1) { @+
  octa trap_loc=incr(g[rWW].o,-4); @+@t}\6{@>
@z

@x [374]
static char arg_count[]={1,3,1,3,3,3,3,2,2,2,1};
@y
@+ static char arg_count[]={1,3,1,3,3,3,3,2,2,2,1};
@z

@x [378]
    if (((Dcache->outbuf.tag.l^addr.l)&-Dcache->bb)==0 &&
@y
    if (((Dcache->outbuf.tag.l^addr.l)&-Dcache->bb)==0 && @|
@z
@x [378]
      if (((Scache->outbuf.tag.l^addr.l)&-Scache->bb)==0 &&
@y
      if (((Scache->outbuf.tag.l^addr.l)&-Scache->bb)==0 && @|
@z

@x [379]
    if (((Dcache->inbuf.tag.l^addr.l)&-Dcache->bb)==0 &&
@y
    if (((Dcache->inbuf.tag.l^addr.l)&-Dcache->bb)==0 && @|
@z
@x [379]
    if (((Dcache->outbuf.tag.l^addr.l)&-Dcache->bb)==0 &&
@y
    if (((Dcache->outbuf.tag.l^addr.l)&-Dcache->bb)==0 && @|
@z
@x [379]
      if (((Scache->inbuf.tag.l^addr.l)&-Scache->bb)==0 &&
@y
      if (((Scache->inbuf.tag.l^addr.l)&-Scache->bb)==0 && @|
@z
@x [379]
      if (((Scache->outbuf.tag.l^addr.l)&-Scache->bb)==0 &&
@y
      if (((Scache->outbuf.tag.l^addr.l)&-Scache->bb)==0 && @|
@z

@x [381]
@ The subroutine |mmgetchars(buf,size,addr,stop)| reads characters
@y
@r @ The subroutine |mmgetchars(buf,size,addr,stop)| reads characters
@z

@x [384]
  register unsigned char *p;
@y
  @+ register unsigned char *p;
@z

@x [385]
  register int s=8*((~a.l)&0x3);
@y
  @+ register int s=8*((~a.l)&0x3);
@z

@x [391]
@ The default |spec_write| just reports its arguments, without actually
@y
@r @ The default |spec_write| just reports its arguments, without actually
@z

@x [395]
@* Index.
@y
@z
