From 7d1b891cb10c6a510f626e7adb0760a54b491695 Mon Sep 17 00:00:00 2001
From: Andreas Scherer <andreas_scherer@alice.de>
Date: Thu, 13 Aug 2015 17:43:18 +0200
Subject: [PATCH 1/6] Fix intermediate bugs.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

On http://www-cs-faculty.stanford.edu/~uno/mmixware.html, DEK says: “I
don't really like to use software that contains known bugs, even if they
are "frozen".”

http://mmix.cs.hm.edu/websvn/wsvn/MMIX/mmixware/trunk/ contains a few
commits to the SVN repository that fix these bugs.

The "silent" feature from MMIX home is _not_ included at this time.
---
 mmix-arith.w  |  4 ++--
 mmix-config.w |  2 +-
 mmix-pipe.w   | 18 ++++++++++++------
 mmmix.w       |  4 ++--
 4 files changed, 17 insertions(+), 11 deletions(-)

diff --git a/mmix-arith.w b/mmix-arith.w
index a94226b..6c1b608 100644
--- a/mmix-arith.w
+++ b/mmix-arith.w
@@ -855,12 +855,12 @@ Some subtleties need to be observed here, in order to
 prevent the sticky bit from being shifted left. If we did not
 shift |yf| left~1 before shifting |zf| to the right, an incorrect
 answer would be obtained in certain cases---for example, if
-$|yf|=2^{54}$, $|zf|=2^{54}+2^{53}-1$, $d=52$.
+$|yf|=2^{54}$, $|zf|=2^{54}+2^{53}-4$, $d=52$.
 
 @<Adjust for difference in exponents@>=
 {
   if (d<=2) zf=shift_right(zf,d,1); /* exact result */
-  else if (d>53) zf.h=0, zf.l=1; /* tricky but OK */
+  else if (d>54) zf.h=0, zf.l=1; /* tricky but OK */
   else {
     if (ys!=zs) d--,xe--,yf=shift_left(yf,1);
     o=zf;
diff --git a/mmix-config.w b/mmix-config.w
index 7e6325e..ca75057 100644
--- a/mmix-config.w
+++ b/mmix-config.w
@@ -956,7 +956,7 @@ n=1;
 if (Scache && Scache->bb>n) n=Scache->bb;
 if (Icache && Icache->bb>n) n=Icache->bb;
 if (Dcache && Dcache->bb>n) n=Dcache->bb;
-n=mem_addr_time+((int)(n+bus_words-1)/bus_words)*j;
+n=mem_addr_time+((int)(n+mem_bus_bytes-1)/mem_bus_bytes)*j;
 if (n>max_cycs) max_cycs=n; /* now |max_cycs| bounds the waiting time */
 ring_size=max_cycs+1;
 ring=(coroutine *)calloc(ring_size,sizeof(coroutine));
diff --git a/mmix-pipe.w b/mmix-pipe.w
index b7f4536..978b9ee 100644
--- a/mmix-pipe.w
+++ b/mmix-pipe.w
@@ -3595,6 +3595,7 @@ static void flush_cache(c,p,keep)
     else d=c->outbuf.data, c->outbuf.data=p->data, p->data=d;
     dd=c->outbuf.dirty, c->outbuf.dirty=p->dirty, p->dirty=dd;
     for (j=0;j<c->bb>>c->g;j++) p->dirty[j]=false;
+    c->outbuf.rank=c->bb; /* this many valid bytes */
     startup(&c->flusher,c->copy_out_time); /* will not be aborted */
 }
 
@@ -3857,7 +3858,7 @@ of the present program are left to the interested reader.
 
 @<Cases for control of special coroutines@>=
 case flush_to_S: {@+register cache *c=(cache *)data->ptr_a;
-  register int block_diff=Scache->bb-c->bb;
+  register int block_diff=Scache->bb-c->outbuf.rank;
   p=(cacheblock*)data->ptr_b;
  switch (data->state) {
   case 0:@+ if (Scache->lock) wait(1);
@@ -3870,7 +3871,9 @@ case flush_to_S: {@+register cache *c=(cache *)data->ptr_a;
     wait(Scache->access_time);
   case 2: @<Fill |Scache->inbuf| with clean memory data@>;
   case 3: @<Allocate a slot |p| in the S-cache@>;
-    if (block_diff) @<Copy |Scache->inbuf| to slot |p|@>;         
+    if (block_diff) @<Copy |Scache->inbuf| to slot |p|@>@;
+    else@+for (j=0;j<Scache->bb>>3;j++) p->data[j]=c->outbuf.data[j];
+    for (j=0;j<Scache->bb>>Scache->g;j++) p->dirty[j]=false;
   case 4: copy_block(c,&(c->outbuf),Scache,p);
     hit_set=cache_addr(Scache,c->outbuf.tag);@+ use_and_fix(Scache,p);
                    /* |p| not moved */
@@ -4121,7 +4124,7 @@ case 10: goto terminate;
 }
 
 @ @<Cases 0 through 4, for the D-cache@>=
-case 0:@+ if (Dcache->lock || (j=get_reader(Dcache)<0)) wait(1);
+case 0:@+ if (Dcache->lock || (j=get_reader(Dcache))<0) wait(1);
   startup(&Dcache->reader[j],Dcache->access_time);
   set_lock(self,Dcache->lock);
   i=j=0;
@@ -4144,7 +4147,7 @@ case 2:@+ if (!clean_lock) goto done; /* premature termination */
   if (Dcache->flusher.next) wait(1);
   if (data->i!=sync) goto Sprep;
   data->state=3;
-case 3:@+ if (Dcache->lock || (j=get_reader(Dcache)<0)) wait(1);
+case 3:@+ if (Dcache->lock || (j=get_reader(Dcache))<0) wait(1);
   startup(&Dcache->reader[j],Dcache->access_time);
   set_lock(self,Dcache->lock);
   i=data->y.o.h, j=data->y.o.l;
@@ -4155,7 +4158,7 @@ Dclean_inc: j++;
     wait(Dcache->access_time);
   }
   goto Dclean_loop;
-case 4:@+ if (Dcache->lock || (j=get_reader(Dcache)<0)) wait(1);
+case 4:@+ if (Dcache->lock || (j=get_reader(Dcache))<0) wait(1);
   startup(&Dcache->reader[j],Dcache->access_time);
   set_lock(self,Dcache->lock);
   p=cache_search(Dcache,data->z.o);
@@ -4602,7 +4605,7 @@ case write_from_wbuf:
     if (ticks.l-write_head->stamp<holding_time && !speed_lock)
       wait(1); /* data too raw */
     if (!Dcache) goto mem_direct; /* not cached */
-    if (Dcache->lock || (j=get_reader(Dcache)<0)) wait(1); /* D-cache busy */
+    if (Dcache->lock || (j=get_reader(Dcache))<0) wait(1); /* D-cache busy */
     startup(&Dcache->reader[j],Dcache->access_time);
     @<Write the data into the D-cache and set |state=4|,
                 if there's a cache hit@>;
@@ -4624,12 +4627,15 @@ register cacheblock *p,*q;
 D-cache (unless it hits in the D-cache), it will go into a secondary cache.
 
 @<Handle write-around when writing to the D-cache@>=
+if (Dcache->filler.next) goto write_restart;
+if ((Scache&&Scache->lock) || (!Scache&&mem_lock)) goto write_restart;
 if (Dcache->flusher.next) wait(1);
 Dcache->outbuf.tag.h=write_head->addr.h;
 Dcache->outbuf.tag.l=write_head->addr.l&(-Dcache->bb);
 for (j=0;j<Dcache->bb>>Dcache->g;j++) Dcache->outbuf.dirty[j]=false;
 Dcache->outbuf.data[(write_head->addr.l&(Dcache->bb-1))>>3]=write_head->o;
 Dcache->outbuf.dirty[(write_head->addr.l&(Dcache->bb-1))>>Dcache->g]=true;
+Dcache->outbuf.rank=Dcache->gg; /* this many valid bytes */
 set_lock(self,wbuf_lock);
 startup(&Dcache->flusher,Dcache->copy_out_time);
 data->state=5;@+ wait(Dcache->copy_out_time);
diff --git a/mmmix.w b/mmmix.w
index 6b4d33c..eb197d0 100644
--- a/mmmix.w
+++ b/mmmix.w
@@ -272,8 +272,8 @@ inst_ptr.o=mem_read(incr(cur_loc,-8*14)); /* \.{Main} */
 inst_ptr.p=NULL;
 cur_loc.h=0x60000000;
 g[255].o=incr(cur_loc,-8); /* place to \.{UNSAVE} */
-cur_dat.l=0x90;
-if (mem_read(cur_dat).h) inst_ptr.o=cur_dat; /* start at |0x90| if nonzero */
+cur_dat.l=0xf0;
+if (mem_read(cur_dat).h) inst_ptr.o=cur_dat; /* start at |0xf0| if nonzero */
 head->inst=(UNSAVE<<24)+255, tail--; /* prefetch a fabricated command */
 head->loc=incr(inst_ptr.o,-4); /* in case the \.{UNSAVE} is interrupted */
 g[rT].o.h=0x80000005, g[rTT].o.h=0x80000006;
-- 
2.9.2

